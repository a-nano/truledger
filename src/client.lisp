; -*- mode: lisp -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; A Trubanc client API. Talks the protocol of server.lisp
;;;

(in-package :trubanc)

(defun make-client (dir)
  (make-instance 'client :db (make-fsdb dir)))

(defclass client ()
  ((db :type db
       :initarg :db
       :accessor db)
   (parser :type (or parser null)
           :initform nil
           :accessor parser)
   (pubkeydb :type (or pubkeydb nill)
             :initform nil
             :accessor pubkeydb)

  ;; Initialized by login() and newuser()
   (id :type (or string null)
       :initform nil
       :accessor id)
   (privkey :initform nil
            :accessor privkey)
   (pubkey :initform nil
           :accessor pubkey)

   ;; initialized by setbank() and addbank()
   (server :type (or server null)
           :initform nil
           :accessor server)
   (bankid :type (or string null)
           :initform nil
           :accessor bankid)

   ;; Set true by getreq()
   (syncedreq-p :type boolean
                :initform nil
                :accessor syncedreq-p)

   ;; True to make process() print the messages it sends and receives
   (showprocess-p :type boolean
                  :initform nil
                  :accessor showprocess-p)

   ;; The last coupon generated by a spend:
   ;; (<bankid>,couponenvelope,<id>,<encrypted-coupon>)
   (coupon :type (or string null)
           :initform nil
           :accessor coupon)

   ;; The last outbox time generated by a spend
   (last-spend-time :type (or string null)
                    :initform nil
                    :accessor last-spend-time)

   ;; Set true to keep history of spend & processinbox
   (keep-history-p :type boolean
                   :initform nil
                   :accessor keep-history-p)

   ;; Used to accumulate timing information from server (perf.lisp)
   (server-times :type (or hash-table null)
                 :initform nil
                 :accessor server-times)

   ;; If non-nil, a function to call with debug strings
   (showprocess :initform nil
                :accessor showprocess)))

(defmethod :initialize-instance :after ((client client) &rest rest)
  (declare (ignore rest))
  (setf (pubkeydb client)
        (make-instance 'pubkeydb
                       :client client
                       :db (db-subdir (db client) $PUBKEY))
        (parser client)
        (make-instance 'parser :keydb (pubkeydb client)))
  (setf (parser-always-verify-sigs-p (parser client)) t))

;; API Methods

(defmethod newuser ((client client) &key passphrase (privkey 3072))
  "Create a new user with the given passphrase, error if already there.
   If privkey is a string, use that as the private key.
   If it is an integer, default 3072, create a new private key with that many bits
   User is logged in when this returns successfully."
  (let ((db (db client))
        (hash (passphrase-hash passphrase)))

    (logout client)

    (when (db-get db $PRIVKEY hash)
      (error "Passphrase already has an associated private key"))

    (when (integerp privkey)
      ;; privkey is size in bits for new private key
      (setq privkey (rsa-generate-key privkey)))

    (let* ((pubkey (encode-rsa-public-key privkey))
           (id (pubkey-id pubkey))
           (privkey-str (encode-rsa-private-key privkey passphrase)))
      (setf (db-get db $PRIVKEY hash) privkey-str)
      (db-put db (pubkeykey id) (format nil "~a~%" (trim pubkey)))

      (setf (id client) id
            (privkey client) privkey
            (pubkey client) pubkey))))

(defmethod get-privkey ((client client) passphrase)
  (let ((db (db client))
        (hash (passphrase-hash passphrase)))
    (decode-rsa-private-key
     (or (db-get db $PRIVKEY hash)
         (error "No account for passphrase in database"))
     passphrase)))

(defmethod login ((client client) passphrase)
  "Log in with the given passphrase. Error if no user associated with passphrase."
  (let* ((privkey (get-privkey client passphrase))
         (pubkey (encode-rsa-public-key privkey))
         (id (pubkey-id pubkey)))
    (setf (id client) id
          (privkey client) privkey
          (pubkey client) pubkey)))

(defmethod login-with-sessionid ((client client) sessionid)
  (let ((passphrase (session-passphrase client sessionid)))
    (unwind-protect (login client passphrase)
      (destroy-password passphrase))
    (setf (syncedreq-p client) t))) ;; no server sync for session login

(defmethod login-new-session ((client client) passphrase)
  "Login, create a new session, and return a sessionid."
    (login client passphrase)
    (make-session client passphrase))

(defmethod logout ((client client))
  (when (id client)
    (remove-session client)
    (setf (id client) nil))
  (let ((privkey (privkey client)))
    (when privkey
      (setf (privkey client) nil)
      (rsa-free privkey))
    (setf (bankid client) nil
          (server client) nil)))

;; All the API methods below require the user to be logged in.
;; id and privkey must be set.

(defmethod current-user ((client client))
  "Return current user ID if logged in, otherwise nil."
  (and (privkey client) (id client)))

(defmethod require-current-user ((client client))
  (or (current-user client) (error "Not logged in")))

(defmethod user-pubkey ((client client) &optional (id (id client)))
  "Return pubkey of a user, default logged-in user"
  (let ((db (db client)))
    (and id (db-get db $PUBKEY id))))

(defstruct bank
  id
  name
  url)

(defmethod getbank ((client client) bankid &optional all)
  "Returns a BANK instance, or NIL if it doesn't find the BANKID.
   If ALL is true, return the bank even if the current user isn't logged in."
  (and (or all (userreq client bankid))
       (make-bank :id bankid
                  :name (bankprop client $NAME bankid)
                  :url (bankprop client $URL bankid))))

(defmethod getbanks ((client client) &optional all)
  "Return all the banks known by the current user,
   as a list of BANK instances.
   (BANK-PUBKEYSIG BANK) will be blank if the user has no account at BANK."
  (let* ((db (db client))
         (id (require-current-user client))
         (banks (db-contents db (strcat $ACCOUNT "/" id "/" $BANK)))
         (res nil))
    (dolist (bankid banks)
      (let ((bank (getbank client bankid all)))
        (when bank (push bank res))))

    (sort (nreverse res) 'string-lessp :key #'bank-name)))

(defun url-p (url)
  "Returns true if $url might be a properly-formed URL."
  (and (stringp url)
       (>= (length url) 5)
       (or (string-equal (subseq url 0 5) "http:")
           (and (>= (length url) 6)
                (string-equal (subseq url 0 6) "https:")))))

(defun parse-coupon (coupon)
  "Parse a coupon into bankid, url, and coupon number.
   Returns three values:
     1) bankid
     2) url
     3) coupon-number
   Coupon can be [$url,$coupon_number] or
   ($bankid,coupon,$url,$coupon_number,$asset,$amount,note:$note)"
  (unless (stringp coupon)
    (error "Coupon not a string"))

  ;; Coupon can be just [$url,$coupon_number]
  ;; or ($id,coupon,$bankurl,$coupon,$asset,$amount,note=$note)
  (setq coupon (trim coupon))
  (let (bankid url coupon-number)
    (cond ((and (> (length coupon) 0)
                (eql (aref coupon 0) #\[))
           (unless (eql #\] (aref coupon (1- (length coupon))))
             (error "Malformed coupon string"))
           (let* ((a (explode #\, (subseq coupon 1 (1- (length coupon))))))
             (unless (eql (length a) 2)
               (error "Malformed coupon string"))
             (setq bankid ""
                   url (trim (car a))
                   coupon-number (trim (cadr a)))))
          (t (let* ((parse (tokenize coupon))
                    (items (print (map 'vector 'cdr parse))))
               ; [$id,coupon,$bankid,
               (unless (>= (length items) 7)
                 (error "Malformed coupon message, < 7 tokens"))
               (unless (equal (elt items 0) #\()
                 (error "Message doesn't start with left paren"))
               (setq bankid (elt items 1)
                     url (elt items 5)
                     coupon-number (elt items 7))
               (unless (id-p bankid)
                 (error "Coupon bankid not an id"))
               (unless (equal #\, (aref items 2))
                 (error "Coupon missing comma 1"))
               (unless (equal (elt items 3) $COUPON)
                 (error "Coupon isn't a coupon message"))
               (unless (equal (aref items 4) #\,)
                 (error "Coupon missing comma 2")))))
    (unless (url-p url)
      (error "Coupon url isn't a url: ~s" url))
    (unless (coupon-number-p coupon-number)
      (error "Coupon number malformed: ~a" coupon-number))
    (values bankid url coupon-number)))

(defmethod verify-coupon ((client client) coupon bankid url)
  "Verify that a message is a valid coupon.
   Check that it is actually signed by the bank that it
   claims to be from.
   Ask the bank whether a coupon of that number exists."
  (let ((parser (parser client))
        coupon-number)
    (verify-bank client url bankid)
    (setq coupon (trim coupon))
    (if (eql #\[ (aref coupon 0))
        (setq coupon-number (nth-value 2 (parse-coupon coupon)))
        (let ((args (client-unpack-bankmsg client coupon $COUPON bankid)))
          (setq coupon-number (getarg $COUPON args))))
    (unless (coupon-number-p coupon-number)
      (error "Malformed coupon number: ~%" coupon-number))

    (let* ((msg (strcat "(0," bankid ",0," coupon-number "):0"))
           (server (make-instance 'server-proxy :url url :client client))
           (msg (process server msg))
           (reqs (parse parser msg)))
      (match-bankreq client (car reqs) $REGISTER bankid)
      (unless (eql 2 (length reqs))
        (error "verifycoupon: expected 2 messages from bank"))
      (match-bankreq client (cadr reqs) $COUPONNUMBERHASH bankid))))

(defmethod verify-bank ((client client) url &optional id)
  "Verify that a bank matches its URL.
   Add the bank to our database if it's not there already.
   Error if ID is non-null and doesn't match bankid at URL.
   Return bankid, or error."
  (unless (url-p url)
    (error "Not a URL: ~%" url))
  (let* ((db (db client))
         (urlhash (sha1 url))
         (bankid (db-get db $BANK $BANKID urlhash)))
    (cond (bankid
           (when (and id (not (eql id bankid)))
             (error "verifybank: id <> bankid"))
           (unless id (setq id bankid)))
          (t
           (let* ((parser (parser client))
                  (msg (strcat "(0," $BANKID ",0):0"));
                  (server (make-instance 'server-proxy :url url :client client))
                  (msg (process server msg))
                  (save-bankid (prog1 (bankid client)
                                 (setf (bankid client) bankid)))
                  (args (unwind-protect (match-message parser msg)
                          (setf (bankid client) save-bankid)))
                  (bankid (getarg $CUSTOMER args))
                  (pubkey (getarg $PUBKEY args))
                  (name (getarg $NAME args)))
             (unless (equal bankid (getarg $BANKID args))
               (error "Bank's register message malformed"))
             (if (not id)
                 (setq id bankid)
                 (unless (equal bankid id)
                   (error "Bankid different than expected")))
             (unless (equal (pubkey-id pubkey) bankid)
               (error "verifybank: Bank's id doesn't match its public key"))
             (unless (bankprop client $URL bankid)
               ;; Initialize the bank in the database
               (setf (db-get db $BANK $BANKID urlhash) bankid
                     (db-get db (bankkey $URL $bankid)) url
                     (db-get db (bankkey $NAME bankid)) name
                     (db-get db (pubkeykey bankid))
                     (format nil "~a~%" (trim pubkey)))))))))

(defmethod addbank ((client client) url &optional name couponok)
  "Add a bank with the given URL to the database.
   URL can be a coupon to redeem that with registration.
   No error, but does nothing, if the bank is already there.
   If the bank is NOT already there, registers with the given NAME and coupon.
   If registration fails, removes the bank and you'll have to add it again
   after getting enough usage tokens at the bank to register.
   Sets the client instance to use this bank until addbank() or setbank()
   is called to change it.
   If COUPONOK is true, does not verify a coupon with the bank before using it."
  (let ((db (db client))
        (bankid nil)
        (realurl nil)
        (coupon nil))
    (require-current-user client)
    (cond ((url-p url)
           (setq realurl url
                 bankid (verify-bank client url)))
          (t (multiple-value-setq (bankid realurl coupon) (parse-coupon url))
             (unless couponok
               (verify-coupon client url bankid realurl))))
    (let ((already-registered-p t))
      (handler-case (setbank client bankid nil)
        (error ()
          (setq already-registered-p nil)))
      (cond (already-registered-p
             ;; User already has an account at this bank.
             ;; Redeem the coupon
             (when coupon
               (redeem client coupon)))
            (t 
             (let ((oldbankid (bankid client))
                   (oldserver (server client)))
               (unwind-protect
                    (progn
                      (setf (bankid client) bankid
                            url (bankprop client $URL bankid))
                      (unless url
                        (error "URL not stored for verified bank: ~s" bankid))
                      (setf (server client)
                            (make-instance 'serverproxy :url url :client client))
                      (register client name coupon bankid))
                 (setf (db-get db (userreqkey client bankid)) nil
                       (bankid client) oldbankid
                       (server client) oldserver))))))))

(defmethod setbank ((client client) bankid &optional (check-p t))
  "Set the bank to the given id.
   Sets the client instance to use this bank until addbank() or setbank()
   is called to change it, by setting $this->bankid and $this->server"
  (let ((url (or (bankprop client $URL bankid)
                 (error "Bank not known: ~s" bankid))))
    (require-current-user client)
    (unless (userbankprop client $REQ bankid)
      (error "User not registered at bank"))
    (setf (bankid client) bankid
          (server client) (make-instance 'serverproxy :url url :client client))

    (when check-p
      (let* ((msg (sendmsg client $BANKID (pubkey client)))
             (args (handler-case (match-message (parser client) msg)
                     (error (c)
                       (setf (bankid client) nil)
                       (error "setbank: Bank's bankid response error: ~a" c)))))
        (unless (equal bankid (getarg $CUSTOMER args))
          (setf (bankid client) nil)
          (error "Bankid changed since we last contacted this bank, old: ~s, new: ~s"
                 bankid (getarg $CUSTOMER args)))
        (unless (and (equal (getarg $REQUEST args) $REGISTER)
                     (equal (getarg $BANKID args) bankid))
          (setf (bankid client) nil)
          (error "Bank's bankid message wrong: ~s" msg))))))

(defmethod current-bank ((client client))
  "Return current bank if the user is logged in and the bank is set, else false."
  (and (current-user client) (server client) (bankid client)))

(defmethod require-current-bank ((client client) &optional msg)
  (unless (current-bank client)
    (error (or msg "Bank not set"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;  All the API methods below require the user to be logged and the bank to be set.
;;;  Do this by calling newuser() or login(), and addbank() or setbank().
;;;  id, privkey, bankid, & server must all be set.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod register ((client client) &optional name coupons bankid)
  "Register at the current bank.
   No error if already registered
   If not registered, and COUPONS is a string or array of strings,
   assumes the string(s) are coupons, encrypts and signs them,
   and sends them to the bank with the registration request."
  (let ((db (db client))
        (id (require-current-user client))
        server)
    (cond ((null bankid)
           (setq bankid (bankid client)
                 server (server client)))
          (t 
           (let ((url (or (bankprop client $URL)
                          (error "In register: Unknown bankid"))))
             (setq server (make-instance 'serverproxy :url url :client client)))))

    (require-current-bank client "In register(): Bank not set")

    ;; If already registered and we know it, nothing to do
    (when (db-get db (userbankkey client $PUBKEYSIG bankid) id)
      (return-from register))

    ;; See if bank already knows us
    ;; Resist the urge to change this to a call to
    ;; get-pubkey-from-server. Trust me.
    (let* ((msg (process server (custmsg client $ID bankid id)))
           args)
      (handler-case
          (setq args (client-unpack-bankmsg client msg $ATREGISTER))
        (error ()
          ;; Bank doesn't know us. Register with bank.
          (setq msg (apply 'custmsg client $REGISTER bankid (pubkey id)
                           (and name (list name))))
          (when coupons
            (when (stringp coupons) (setq coupons (list coupons)))
            (let ((pubkey (db-get (pubkeydb client) bankid)))
              (unless pubkey (error "Can't get bank public key"))
              (dolist (coupon coupons)
                (dotcat msg "." (custmsg client $COUPONENVELOPE bankid
                                         (pubkey-encrypt coupon pubkey))))))
          (setq msg (process server msg)
                args (client-unpack-bankmsg msg $ATREGISTER))))

      ;; Didn't fail. Notice registration here
      (setq args (getarg $MSG args))
      (unless (and (equal (getarg $CUSTOMER args) id)
                   (equal (getarg $REQUEST args) $REGISTER)
                   (equal (getarg $BANKID args) bankid))
        (error "Malformed registration message"))
      (let* ((pubkey (getarg $PUBKEY args))
             (keyid (pubkey-id pubkey)))
        (unless (equal keyid id)
          (error "Server's pubkey wrong"))
        (setf (db-get db (userbankkey client $PUBKEYSIG) id) msg
              (db-get db (userbankkey client $REQ)) "-1")))))


(defstruct contact
  id
  name
  nickname
  note
  contact-p)

(defun string-compare (s1 s2)
  (cond ((string-lessp s1 s2) 1)
        ((string-equal s1 s2) 0)
        (t -1)))

(defun properties-compare (a1 a2 keys &optional (comparef 'string-compare))
  (dolist (key keys 0)
    (let ((res (funcall comparef (funcall key a1) (funcall key a2))))
      (unless (eql 0 res) (return res)))))

(defun properties-lessp (a1 a2 keys &optional (comparef 'string-compare))
  (< (properties-compare a1 a2 keys comparef) 0))

(defun contacts-lessp (c1 c2)
  (properties-lessp c1 c2 '(contact-nickname contat-name contact-id)))

(defmethod getcontacts ((client client))
  "Get contacts for the current bank.
   Contacts are sorted by nickname, name, id
   Signals an error or returns a list of CONTACT instances."
  (let ((db (db client)))
    (require-current-bank client "In getcontacts(): Bank not set")
    (with-db-lock (db (userreqkey client))
      (let* ((ids (db-contents db (contactkey client)))
             (res (loop
                     for otherid in ids
                     for contact = (getcontact-internal client otherid)
                     when contact
                     collect contact)))
        (sort res 'contacts-lessp)))))

(defmethod getcontact ((client client) otherid &optional add)
  "Get a contact, by ID. Return a CONTACT instance."
  (when (current-bank client)
    (with-db-lock ((db client) (userreqkey client))
      (getcontact-internal client otherid add))))

(defmethod getcontact-internal ((client client) otherid &optional add (probebank t))
  (let ((pubkeysig (contactprop client otherid $PUBKEYSIG)))
    (unless pubkeysig
      (cond (add
             (addcontact-internal client otherid)
             (setq pubkeysig (contactprop client otherid $PUBKEYSIG)))
            (probebank
             (multiple-value-bind (pubkeysig name) (get-id client otherid)
               (return-from getcontact-internal
                 (and pubkeysig (make-contact :id otherid :name name)))))))
    (when pubkeysig
      (make-contact
       :id otherid
       :name (contactprop client otherid $NAME)
       :nickname (contactprop client otherid $NICKNAME)
       :note (contactprop client otherid $NOTE)
       :contact-p t))))
  
(defmethod addcontact ((client client) otherid &optional nickname note)
  "Add a contact to the current bank.
   If it's already there, change its nickname and note, if included."
  (require-current-bank client)
  (with-db-lock ((db client) (userreqkey client))
    (addcontact-internal client otherid nickname note)))

(defmethod addcontact-internal ((client client) otherid &optional nickname note)
  (let ((db (db client))
        pubkeysig
        name)
    (cond ((contactprop client otherid $PUBKEYSIG)
           (when nickname
             (setf (db-get db (contactkey client otherid $NICKNAME)) nickname))
           (when note
             (setf (db-get db (contactkey client otherid $NOTE)) note)))
          (t
           (multiple-value-setq (pubkeysig name) (get-id client otherid))
           (unless pubkeysig (error "Can't find id at bank: ~s" otherid))
           (unless nickname
             (setq nickname (or name "anonymous")))
           (setf (db-get db (contactkey client otherid $NICKNAME)) nickname
                 (db-get db (contactkey client otherid $NOTE)) note
                 (db-get db (contactkey client otherid $NAME)) name
                 (db-get db (contactkey client otherid $PUBKEYSIG)) pubkeysig)))
    pubkeysig))

(defmethod deletecontact ((client client) otherid)
  "Delete a contact from the current bank."
  (let ((db (db client)))
    (with-db-lock (db (userreqkey client))
      (let ((key (contactkey client otherid)))
        (dolist (k (db-contents db key))
          (setf (db-get db key k) nil))))))

(defmethod get-id ((client client) id)
  "Check for an id at the bank. Return false if not there.
   Return two values: pubkeysig & name"
  (let ((db (db client))
        (bankid (bankid client)))
    (when bankid
      (let* ((key (append-db-keys (userbankkey client $PUBKEYSIG) id))
             (pubkeysig (db-get db key))
             (needstore nil))
        (unless pubkeysig
          (setq pubkeysig (sendmsg client $ID bankid id)
                needstore t))
        (let ((args (ignore-errors
                      (client-unpack-bankmsg client pubkeysig $ATREGISTER))))
          (when args
            (setq args (getarg $MSG args))
            (let ((pubkey (getarg $PUBKEY args))
                  (name (getarg $NAME args)))
              (when (equal id (pubkey-id pubkey))
                (when needstore (setf (db-get db key) pubkeysig))
                (values pubkeysig name)))))))))

(defmethod getaccts ((client client))
  "GET sub-account names.
   Returns an error string or an array of the sub-account names."
  (let ((db (db client)))

    (require-current-bank client "In getaccts(): Bank not set")
    (init-bank-accts client)
    
    (sort (db-contents db (userbalancekey client)) 'string-lessp)))

(defstruct asset
  id
  assetid
  scale
  precision
  name
  issuer
  percent)

(defun asset-lessp (a1 a2)
  (properties-lessp a1 a2 '(asset-name asset-id)))

(defmethod getassets ((client client))
  "Return the assets for which the customer has balances as
   a list of ASSET instances."
  (let ((db (db client))
        (bankid (bankid client))
        (res nil))
    (when bankid
      (let* ((key (userbalancekey client))
             (accts (db-contents db key)))
        (dolist (acct accts)
          (let ((assetids (db-contents db key acct)))
            (dolist (assetid assetids)
              (let ((asset (getasset client assetid)))
                (when asset (push asset res)))))))
      (sort res 'asset-lessp))))

(defmethod getasset ((client client) assetid &optional forceserver)
  "Look up an asset.
   Signals an error or returns an ASSET instance.
   If the asset isn't found in the client database, looks it up on the
   server, and stores it in the client database."
  (let ((db (db client)))
    (require-current-bank client "In getacct(): Bank not set")
    (let ((key (assetkey client assetid)))
      (with-db-lock (db key)
        (let ((msg (unless forceserver (db-get db key)))
              args)
          (cond (msg
                 (setq args (client-unpack-bankmsg client msg $ATASSET)))
                (t
                 (setq args (getasset-internal client assetid key))))
          (let ((req (cadr (getarg $UNPACK-REQS-KEY args)))
                (args (getarg $MSG args))
                (percent nil)
                (issuer nil))
            (when req
              (let* ((args1 (getarg $MSG (match-bankreq client req $ATSTORAGE))))
                (setq issuer (getarg $CUSTOMER args1)
                      percent (getarg $PERCENT args1))))
            (make-asset
             :id (getarg $CUSTOMER args)
             :assetid assetid
             :scale (getarg $SCALE args)
             :precision (getarg $PRECISION args)
             :name (getarg $ASSETNAME args)
             :issuer issuer
             :percent percent)))))))

(defmethod getasset-internal ((client client) assetid key)
  (let* ((db (db client))
         (bankid (bankid client))
         (req (getreq client))
         (msg (sendmsg client $GETASSET bankid req assetid))
         (args (client-unpack-bankmsg client msg $ATASSET))
         (msgargs (getarg $MSG args)))
    (unless (and (equal (getarg $REQUEST  msgargs) $ASSET)
                 (equal (getarg $BANKID msgargs) bankid)
                 (equal (getarg $ASSET msgargs) assetid))
      (error "Bank wrapped wrong object with @asset"))
    (setf (db-get db key) msg)
    args))

(defmethod addasset ((client client) scale precision assetname &optional percent)
  (let ((db (db client)))
    (with-db-lock (db (userreqkey client))
      (let ((id (id client))
            (bankid (bankid client))
            (server (server client))
            (parser (parser client)))

        (unless (and id bankid)
          (error "Can't add asset unless bank is set"))

        (let* ((assetid (assetid id scale precision assetname))
               (time (client-gettime client))
               (tranfee (getfees client))
               (tokenid (tranfee-assetid tranfee))
               (msg (custmsg client $ASSET bankid assetid scale precision assetname))
               (nonbankp (not (equal id bankid)))
               (bal1 (and nonbankp
                          (balance-amount (getbalance client $MAIN tokenid))))
               (oldasset (ignore-errors (getasset client assetid)))
               (bal2 nil)
               (mainbals (make-equal-hash))
               (acctbals (make-equal-hash $MAIN mainbals))
               balancehash)
          (when nonbankp
            (let ((tokens (if oldasset 1 2))
                  (ispos (>= (bccomp bal1 0) 0)))
              (setq bal1 (bcsub bal1 tokens))
              (when (and ispos (< (bccomp bal1 0) 0))
                (error (if oldasset
                           "You need 1 usage token to update an asset"
                           "You need 2 usage tokens to create a new asset")))))
          (setq bal1 (custmsg client $BALANCE bankid time tokenid bal1))
          (unless oldasset
            (setq bal2 (custmsg client $BALANCE bankid time assetid "-1")))
          (when bal1
            (setf (gethash tokenid mainbals) bal1))
          (when bal2
            (setf (gethash assetid mainbals) bal2))
          (when nonbankp
            (setq balancehash (balancehashmsg client time acctbals)))

          (when percent
            (dotcat msg "." (custmsg client $STORAGE bankid time assetid percent)))
          (when bal1 (dotcat msg "." bal1))
          (when bal2 (dotcat msg "." bal2))
          (when balancehash (dotcat msg "." balancehash))

          (setq msg (process server msg))

          ;; Request sent. Check for error
          (let ((reqs (parse parser msg))
                gotbal1
                gotbal2
                gotstorage)
            (dolist (req reqs)
              (let* ((args (match-bankreq client req))
                     (msg (get-parsemsg req))
                     (m (trim (get-parsemsg (getarg $MSG args)))))
                (cond ((equal m bal1) (setq gotbal1 msg))
                      ((equal m bal2) (setq gotbal2 msg))
                      ((equal m percent) (setq gotstorage msg)))))
            (when (or (and bal1 (not gotbal1))
                      (and bal2 (not gotbal2)))
              (error "While adding asset: missing returned balance from server"))
            (when (and percent (not gotstorage))
              (error "While adding asset: storage fee not returned from server"))

            ;; All is well. Commit the balance changes
            (when bal1 (setf (db-get db (userbalancekey $MAIN tokenid)) gotbal1))
            (when bal2 (setf (db-get db (userbalancekey $MAIN assetid)) gotbal2))
            
            (getasset client assetid t)))))))

#||
;; Continue here.

  // Look up the transaction cost.
  // Returns an error string or an array of the form:
  //
  //   array($t->TRANFEE => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                    $t->AMOUNT => $amount),
  //                              ...),
  //         $t->REGFEE => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                   $t->AMOUNT => $assetid),
  //                             ...),
  //         $t->FEE|<operation> => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                            $t->AMOUNT => $assetid),
  //                                      ...),
  //         ...)
  //
  // Currently, only the tranfee and regfee are supported by the server,
  // and only a single fee, in usage tokens, is charged for each.
  // So that's all the spend code handles.
  //
  // If the asset isn't found in the client database, looks it up on the
  // server, and stores it in the client database.
  function getfees($reload=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfees(): Bank not set";

    $key = $this->tranfeekey();
    $lock = $db->lock($key, true);
    $msg = $db->get($key);
    if ($msg) {
      $db->unlock($lock);
      $args = $this->unpack_bankmsg($msg, $t->TRANFEE);
      if (is_string($args)) return "While matching tranfee: $args";
    } else {
      $args = $this->getfees_internal($key);
      $db->unlock($lock);
      if (is_string($args)) return $args;
    }

    $tranfee = array($t->ASSET => $args[$t->ASSET],
                     $t->AMOUNT => $args[$t->AMOUNT]);

    $msg = $this->regfee();
    if (!$msg) return "Regfee not initialized";
    $args = $this->unpack_bankmsg($msg, $t->REGFEE);
    if (is_string($args)) return "While matching regfee: $args";

    $regfee = array($t->ASSET => $args[$t->ASSET],
                    $t->AMOUNT => $args[$t->AMOUNT]);

    return array($t->TRANFEE => $tranfee,
                 $t->REGFEE => $regfee);
  }

  function getfees_internal($key) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;
    $bankid = $this->bankid;

    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getfees";
    $msg = $this->sendmsg($t->GETFEES, $bankid, $req);
    $reqs = $parser->parse($msg);
    if (!$reqs) return "While parsing getfees return message: " . $parser->errmsg;
    $feeargs = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While matching getfees return: $args";
      if ($args[$t->REQUEST] == $t->TRANFEE) {
        $db->put($key, $parser->get_parsemsg($req));
        $feeargs = $args;
      } elseif ($args[$t->REQUEST] == $t->REGFEE) {
        $db->put($this->regfeekey(), $parser->get_parsemsg($req));
      }
    }

    if (!$feeargs) $feeargs = "No tranfee from getfees request";
    return $feeargs;
  }

  // Get user balances for all sub-accounts or just one.
  // Returns an error string or an array of items of the form:
  //
  //    array($acct => array($t->ASSET =>
  //                         array($t->ASSET => $assetid,
  //                               $t->ASSETNAME => $assetname,
  //                               $t->AMOUNT => $amount,
  //                               $t->TIME => $time,
  //                               $t->FORMATTEDAMOUNT => $formattedamount),
  //                         ...),
  //          ...)
  //
  // where $assetid & $assetname describe the asset, $amount is the
  // amount, as an integer, $formattedamount is the amount as a
  // decimal number with the scale and precision applied, and $acct
  // is the name of the sub-account(s).
  //
  // The $acct arg is true for all sub-accounts, false for the
  // $t->MAIN sub-account only, or a string for that sub-account only.
  // The $assetid arg is false for all asset or an ID for that asset only.
  //
  // If you a specific $acct and a specific $assetid, the result
  // is an array mapping property names to values, not an array of arrays.
  function getbalance($acct=true, $assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getbalance(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getbalance_internal($acct, $assetid);
    $db->unlock($lock);

    return $res;
  }

  function compareaccts($a1, $a2) {
    $t = $this->t;

    if ($a1 == $t->MAIN) {
      if ($a2 == $t->MAIN) return 0;
      return -1;
    } elseif ($a2 == $t->MAIN) return 1;
    return strcmp(strtolower($a1), strtolower($a2));
  }

  function comparebalances($b1, $b2) {
    $t = $this->t;

    return $this->comparearrays($b1, $b2, array($t->ASSETNAME, $t->ASSET));
  }

  function getbalance_internal($inacct, $inassetid) {
    $t = $this->t;
    $db = $this->db;

    if (!$inacct) $inacct = $t->MAIN;
    if (is_string($inacct)) $accts = array($inacct);
    else {
      $accts = $db->contents($this->userbalancekey());
      usort($accts, array('client', 'compareaccts'));
    }

    $res = array();
    foreach ($accts as $acct) {
      if ($inassetid) $assetids = array($inassetid);
      else $assetids = $db->contents($this->userbalancekey($acct));
      $assets = array();
      foreach ($assetids as $assetid) {
        $amount = $this->userbalanceandtime($acct, $assetid, $time);
        if (!is_numeric($amount)) return "While gathering balances: $amount";
        $asset = $this->getasset($assetid);
        if (is_string($asset)) {
          $formattedamount = $amount;
          $assetname = "Unknown asset";
        } else {
          $formattedamount = $this->format_asset_value($amount, $asset);
          $assetname = $asset[$t->ASSETNAME];
        }
        $assets[$assetid] = array($t->ASSET => $assetid,
                                  $t->ASSETNAME => $assetname,
                                  $t->AMOUNT => $amount,
                                  $t->TIME => $time,
                                  $t->FORMATTEDAMOUNT => $formattedamount);
      }
      uasort($assets, array('client', 'comparebalances'));
      $res[$acct] = $assets;
    }
    if (is_string($inacct) && $inassetid) {
      if (count($res) == 0) $res = false;
      else $res = $res[$inacct][$inassetid];
    }
    return $res;
  }

  // Get the fraction balance for a particular assetid, or all assetids,
  // if $assetid is false. Result is:
  // array($assetid => array($t->AMOUNT => $amount,
  //                         $t->SCALE => $scale
  //                         $t->ASSETNAME => $assetname))
  // Amounts are raw, not scaled.
  // If an $assetid is specified, does not wrap the outer array around the result.
  function getfraction($assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfraction(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getfraction_internal($assetid);
    $db->unlock($lock);

    return $res;
  }

  function getfraction_internal($inassetid) {
    $t = $this->t;
    $db = $this->db;

    if ($inassetid) $assetids = array($inassetid);
    else $assetids = $db->contents($this->userfractionkey());
    $res = array();
    foreach ($assetids as $assetid) {
      $key = $this->userfractionkey($assetid);
      $msg = $db->get($key);
      if ($msg) {
        $args = $this->unpack_bankmsg($msg, $t->ATFRACTION);
        if (is_string($args)) return "While unpacking fraction msg: $args";
        $args = $args[$t->MSG];
        $fraction = $args[$t->AMOUNT];
        $asset = $this->getasset($assetid);
        if (is_string($asset)) return "Error getting asset: $asset";
        $scale = $asset[$t->SCALE];
        $assetname = $asset[$t->ASSETNAME];
        $res[$assetid] = array($t->AMOUNT => $fraction,
                               $t->SCALE => $scale,
                               $t->ASSETNAME => $assetname);
      }      
    }
    if ($inassetid) return (@$res[$inassetid]);
    return $res;
  }

  // Get the storagefee balance for a particular assetid, or all assetids,
  // if $assetid is false. Result is:
  // array($assetid => array($t->ASSET => $assetid,
  //                         $t->ASSETNAME => $assetname
  //                         $t->AMOUNT => $amount,
  //                         $t->TIME => $time,
  //                         $t->FORMATTEDAMOUNT => $formattedamount)
  // If an $assetid is specified, does not wrap the outer array around the result.
  function getstoragefee($assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfraction(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getstoragefee_internal($assetid);
    $db->unlock($lock);

    return $res;
  }

  function getstoragefee_internal($inassetid) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $res = array();
    $key = $this->userstoragefeekey();
    if ($inassetid) $assetids = array($inassetid);
    else $assetids = $db->contents($key);
    foreach ($assetids as $assetid) {
      $msg = $db->get("$key/$assetid");
      $args = $this->unpack_bankmsg($msg, $t->STORAGEFEE);
      if (is_string($args)) return ("Error parsing storage fee: $args");
      $time = $args[$t->TIME];
      $assetid = $args[$t->ASSET];
      $amount = $args[$t->AMOUNT];
      $amt = $amount;
      $u->normalize_balance($amt, $fraction, 0);
      if ($amt) {
        $asset = $this->getasset($assetid);
        if (is_string($asset)) {
          $formattedamount = $amt;
          $assetname = "Unknown asset";
        } else {
          $formattedamount = $this->format_asset_value($amt, $asset);
          $assetname = $asset[$t->ASSETNAME];
        }
        $res[$assetid] = array($t->TIME => $time,
                               $t->ASSET => $assetid,
                               $t->ASSETNAME => $assetname,
                               $t->AMOUNT => $amount,
                               $t->TIME => $time,
                               $t->FORMATTEDAMOUNT => $formattedamount);
      }
    }
    uasort($res, array('client', 'comparebalances'));
    if ($inassetid) {
      if (count($res) == 0) $res = false;
      else $res = $res[$inassetid];
    }
    return $res;
  }

  // Enable or disable history
  function keephistory($enable) {
    $this->keephistory = $enable;
    return false;
  }

  // Initiate a spend
  // $toid is the id of the recipient of the spend
  //   May be $t->COUPON to generate a coupon
  //   In that case, the coupon itself can be fetched with getcoupon()
  // $assetid is the id of the asset to spend
  // $formattedamount is the formatted amount to spend
  // $acct is the source sub-account, default $t->MAIN
  // $acct can also be array($fromacct, $toacct), for a transfer.
  // In that case $toid should be the logged in ID.
  // Fees are always taken from $t->MAIN
  function spend($toid, $assetid, $formattedamount, $acct=false, $note=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In spend(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $parser->verifysigs(false);

    $lock = $db->lock($this->userreqkey());
    $res = $this->spend_internal($toid, $assetid, $formattedamount, $acct, $note);
    if ($res) {
      // Storage fee may have changed. Reload the asset.
      if ($this->reload_asset_p($assetid)) {
        $res = $this->spend_internal($toid, $assetid, $formattedamount, $acct, $note);
      }
    }
    $db->unlock($lock);

    $parser->verifysigs(true);

    if ($res) $this->forceinit();

    return $res;
  }

  function spend_internal($toid, $assetid, $formattedamount, $acct, $note) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $id = $this->id;
    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    if (!$acct) $acct = $t->MAIN;
    $toacct = $t->MAIN;
    if (!is_string($acct)) {
      $toacct = $acct[1];
      $acct = $acct[0];
      if (!(is_string($acct) && is_string($toacct))) {
        return "Bad accts: from: $acct, to: $to_acct";
      }
    }

    if ($id == $toid && $acct == $toacct) {
      return "Transfer from and to the same acct ($acct). Nothing to do.";
    }

    $amount = $this->unformat_asset_value($formattedamount, $assetid);
    if (bccomp($amount, 0) < 0) {
      $bal = $this->userbalance($acct, $assetid);
      if ($bal != $amount) {
        return "Negative spends must be for the whole issuer balance";
      }
    }

    $oldamount = $this->userbalanceandtime($acct, $assetid, $oldtime);
    if (!is_numeric($oldamount)) {
      return "Error getting balance for asset in acct $acct: $oldamount";
    }

    $time = $this->gettime();
    if (!$time) return "Unable to get timestamp for transaction from bank";

    $storagefee = 0;
    $digits = 0;
    $percent = $this->storageinfo($assetid, $fraction, $fractime);
    if ($percent) {
      $digits = $u->fraction_digits($percent);
      $fracfee = $u->storagefee($fraction, $fractime, $time, $percent, $digits);
      $storagefee = $u->storagefee($oldamount, $oldtime, $time, $percent, $digits);
      $storagefee = bcadd($storagefee, $fracfee, $digits);
      $baseoldamount = $oldamount;
      $oldamount = bcsub($oldamount, $storagefee, $digits);
      $u->normalize_balance($oldamount, $fraction, $digits);
    }

    $newamount = bcsub($oldamount, $amount);
    if (bccomp($oldamount, 0) >= 0 &&
        bccomp($newamount,  0) < 0) {
      if ($id == $toid && $percent && bccomp($amount, $baseoldamount) <= 0) {
        // User asked to transfer less than the whole amount, but the storage fee
        // put it over. Reduce amount to leave 0 in $acct
        $amount = $oldamount;
        $newamount = 0;
      } else return "Insufficient balance";
    }

    if ($id == $toid) {
      $oldtoamount = $this->userbalanceandtime($toacct, $assetid, $totime);
      if ($percent && $oldtoamount) {
        $tofee = $u->storagefee($oldtoamount, $totime, $time, $percent, $digits);
        $storagefee = bcadd($storagefee, $tofee, $digits);
        $oldtoamount = bcsub($oldtoamount, $tofee, $digits);
      }
      $newtoamount = bcadd($oldtoamount, $amount, $digits);
      if ($percent) $u->normalize_balance($newtoamount, $fraction, $digits);
      if (bccomp($oldtoamount, 0) < 0 &&
          bccomp($newtoamount, 0) >=0) {
        // This shouldn't be possible.
        // If it happens, it means the asset is out of balance.
        return "Asset out of balance";
      }
    }

    $tranfee = false;
    $tranfee_amt = false;
    $need_fee_balance = false;
    if ($id != $bankid) {
      $fees = $this->getfees();
      if (is_string($fees)) return $fees;
      $tranfee = $fees[$t->TRANFEE];
      $tranfee_asset = $tranfee[$t->ASSET];
      if ($id != $toid) $tranfee_amt = $tranfee[$t->AMOUNT];
      else $tranfee_amt = ($oldtoamount === false) ? 1 : 0;
      if ($tranfee_asset == $assetid && $t->MAIN == $acct) {
        $newamount = bcsub($newamount, $tranfee_amt);
        if (bccomp($oldamount, 0) >= 0 &&
            bccomp($newamount, 0) < 0) {
          return "Insufficient balance for transaction fee";
        }
      } elseif ($id == $toid && $tranfee_asset == $assetid && $t->MAIN = $toacct) {
        $newtoamount = bcsub($newtoamount, $tranfee_amt);
        if ($newtoamount == $oldtoamount) {
          "Transferring one token to a new acct is silly";
        }
        if (bccomp($oldtoamount, 0) >= 0 &&
            bccomp($newtoamount, 0) < 0) {
          return "Insufficient destination balance for transaction fee";
        }
      } else {
        $old_fee_balance = $this->userbalance($t->MAIN, $tranfee_asset);
        $fee_balance = bcsub($old_fee_balance, $tranfee_amt);
        $need_fee_balance = true; // $fee_balance could be 0
        if (bccomp($old_fee_balance, 0) >= 0 &&
            bccomp($fee_balance, 0) < 0) {
          return "Insufficient tokens for transaction fee";
        }
      }
    }

    if ($note) $spend = $this->custmsg($t->SPEND, $bankid, $time, $toid,
                                       $assetid, $amount, $note);
    else $spend = $this->custmsg($t->SPEND, $bankid, $time, $toid, $assetid, $amount);
    $feeandbal = '';
    $feebal = false;
    if ($tranfee_amt) {
      if ($id != $toid) {
        $feemsg = $this->custmsg
          ($t->TRANFEE, $bankid, $time, $tranfee_asset, $tranfee_amt);
        $feeandbal = $feemsg;
      }
      if ($need_fee_balance) {
        $feebal = $this->custmsg
          ($t->BALANCE, $bankid, $time, $tranfee_asset, $fee_balance);
        if ($feeandbal) $feeandbal .= '.';
        $feeandbal .= $feebal;
      }
    }      
    $balance = $this->custmsg
      ($t->BALANCE, $bankid, $time, $assetid, $newamount, $acct);
    $tobalance = false;
    if ($id == $toid) {
      $tobalance = $this->custmsg($t->BALANCE, $bankid, $time,
                                  $assetid, $newtoamount, $toacct);
    }
    $outboxhash = '';
    if ($id != $bankid && $id != $toid) {
      $outboxhash = $this->outboxhashmsg($time, $spend);
    }

    // Compute balancehash
    $balancehash = false;
    if ($id != $bankid) {
      if ($feebal) {
        if ($t->MAIN == $acct) {
          $acctbals = array($acct => array($assetid => $balance,
                                           $tranfee_asset => $feebal));
          if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
        } elseif ($id == $toid && $t->MAIN == $toacct) {
          $acctbals = array($acct => array($assetid => $balance),
                            $t->MAIN => array($assetid => $tobalance,
                                              $tranfee_asset => $feebal));
        } else {
          $acctbals = array($acct => array($assetid => $balance),
                            $t->MAIN => array($tranfee_asset => $feebal));
          if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
        }
      } else {
        $acctbals = array($acct => array($assetid => $balance));
        if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
      }
      $balancehash = $this->balancehashmsg($time, $acctbals);
    }

    // Prepare storage fee related message components
    if ($percent) {
      $storagefeemsg = $this->custmsg($t->STORAGEFEE, $bankid, $time, $assetid, $storagefee);
      $fracmsg = $this->custmsg($t->FRACTION, $bankid, $time, $assetid, $fraction);
    }

    // Send request to server, and get response
    $msg = $spend;
    if ($feeandbal) $msg.= ".$feeandbal";
    $msg .= ".$balance";
    if ($tobalance) $msg .= ".$tobalance";
    if ($outboxhash) $msg .= ".$outboxhash";
    if ($balancehash) $msg .= ".$balancehash";
    if ($percent) $msg .= ".$storagefeemsg.$fracmsg";
    $msg = $server->process($msg);

    $reqs = $parser->parse($msg);
    if (!$reqs) return "Can't parse bank return from spend: $msg";
    $spendargs = $this->match_bankreq($reqs[0], $t->ATSPEND);
    if (is_string($spendargs)) {
      $args = $this->match_bankreq($reqs[0]);
      if (is_string($args)) return $args;
      $request = $args[$t->REQUEST];
      if ($request = $t->FAILED) return "Spend request failed: " . $args[$t->ERRMSG];
      return "Spend request returned unknown message type: " . $request;
    }

    $msgs = array($spend => true,
                  $balance => true);
    if ($tobalance) $msgs[$tobalance] = true;
    if ($outboxhash) $msgs[$outboxhash] = true;
    if ($balancehash) $msgs[$balancehash] = true;
    if ($feeandbal) {
      if ($feemsg) $msgs[$feemsg] = true;
      if ($feebal) $msgs[$feebal] = true;
    }
    if ($percent) {
      $msgs[$storagefeemsg] = true;
      $msgs[$fracmsg] = true;
    }

    $coupon = false;
    foreach ($reqs as $req) {
      $msg = $parser->get_parsemsg($req);
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "Error in spend response: $args";
      if ($args[$t->REQUEST] == $t->COUPONENVELOPE) {
        if ($coupon) return "Multiple coupons returned from server";
        $coupon = $msg;
        $encryptedcoupon = $args[$t->ENCRYPTEDCOUPON];
      } else {
        $m = $args[$t->MSG];
        if (!$m) return "No wrapped message in spend return: $msg";
        $m = trim($parser->get_parsemsg($m));
        if (!$msgs[$m]) return "Returned message wasn't sent: '$m'";
        if (is_string($msgs[$m])) return "Duplicate returned message: '$m'";
        $msgs[$m] = $msg;
      }
    }

    foreach ($msgs as $m => $msg) {
      if ($msg === true) return "Message not returned from spend: $m";
    }

    // All is well. Commit this baby.
    $db->put($this->userbalancekey($acct, $assetid), $msgs[$balance]);
    if ($tobalance) {
      $db->put($this->userbalancekey($toacct, $assetid), $msgs[$tobalance]);
    }
    if ($outboxhash) {
      $db->put($this->useroutboxhashkey(), $msgs[$outboxhash]);
    }
    if ($balancehash) {
      $db->put($this->userbalancehashkey(), $msgs[$balancehash]);
    }
    $spend = $msgs[$spend];
    if ($feeandbal) {
      $spend = "$spend." . $msgs[$feemsg];
      if ($feebal) {
        $db->put($this->userbalancekey($t->MAIN, $tranfee_asset), $msgs[$feebal]);
      }
    }
    if ($coupon) {
      $spend .= ".$coupon";
      $this->coupon = $encryptedcoupon;
    }
    if ($id != $toid && $id != $bankid) {
      $db->put($this->useroutboxkey($time), $spend);
    }
    $this->lastspendtime = $time;

    if ($percent) {
      $db->put($this->userfractionkey($assetid), $msgs[$fracmsg]);
    }

    if ($this->keephistory) {
      $key = $this->userhistorykey();
      $db->put("$key/$time", $spend);
    }

    return false;    
  }

  // Reload an asset from the server.
  // Return true if the storage percent changed.
  function reload_asset_p($assetid) {
    $t = $this->t;

    $asset = $this->getasset($assetid);
    if (is_string($asset)) return false;
    $percent = $asset[$t->PERCENT];
    $asset = $this->getasset($assetid, true);
    return ($percent != $asset[$t->PERCENT]);
  }

  function spendreject($time, $note=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In spendreject(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $parser->verifysigs(false);

    $lock = $db->lock($this->userreqkey());
    $res = $this->spendreject_internal($time, $note);
    $db->unlock($lock);

    $parser->verifysigs(true);

    if ($res) $this->forceinit();

    return $res;
  }

  function spendreject_internal($time, $note) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $bankid = $this->bankid;
    $id = $this->id;
    $db = $this->db;
    $server = $this->server;
    $parser = $this->parser;

    $msg = $this->useroutbox($time);
    if (!$msg) return "No outbox entry at time: $time";
    $reqs = $parser->parse($msg);
    if (!$reqs) return "In spendreject, parse error: " . $parser->errmsg;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return $args;
      if ($args[$t->REQUEST] == $t->COUPONENVELOPE) {
        $coupon = $args[$t->ENCRYPTEDCOUPON];
        if ($coupon) {
          $coupon = $this->ssl->privkey_decrypt($coupon, $this->privkey);
          return $this->redeem($coupon);
        }
      }
    }

    if ($note) {
      $msg = $this->custmsg($t->SPENDREJECT, $bankid, $time, $id, $note);
    } else {
      $msg = $this->custmsg($t->SPENDREJECT, $bankid, $time, $id);
    }

    $bankmsg = $server->process($msg);
    $args = $this->unpack_bankmsg($bankmsg, $t->INBOX);
    if (is_string($args)) return $args;

    $time = $args[$t->TIME];
    $args = $args[$t->MSG];
    $msg2 = $parser->get_parsemsg($args);
    if (trim($msg2) != trim($msg)) return "Bank return didn't wrap request";
    $key = $this->userinboxkey();
    $db->put("$key/$time", $bankmsg);

    return false;
  }

  function bccompnot($x, $y) {
    return bccomp($y, $x);
  }

  function gethistorytimes() {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In gethistorytimes(): Bank not set";

    $key = $this->userhistorykey();
    $res = $db->contents($key);
    usort($res, array($this, 'bccompnot'));

    return $res;
  }

  // Get the history items for $time.
  // Return false if there is no corresponding item.
  // Otherwise, return an array of matched inner message arrays.
  // Return an error string if there is an error parsing or matching.
  function gethistoryitems($time) {
    $t = $this->t;
    $u = $this->u;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In gethistoryitems(): Bank not set";

    $key = $this->userhistorykey();
    $msg = $db->get("$key/$time");
    if (!$msg) return false;

    $reqs = $parser->parse($msg);
    if (!$reqs) return "While parsing history item: " . $parser->errmsg;
    $res = array();
    foreach ($reqs as $req) {
      $args = $u->match_pattern($req);
      if (is_string($args)) return "While matching history item: " . $args;
      $inner = @$args[$t->MSG];
      if ($inner) {
        $atrequest = $args[$t->REQUEST];
        $args = $u->match_pattern($inner);
        if (is_string($args)) return "While matching inner history item: $args";
        $args[$t->ATREQUEST] = $atrequest;
      }
      $assetid = @$args[$t->ASSET];
      $amount = @$args[$t->AMOUNT];
      if ($assetid && !($amount === false)) {
        $asset = $this->getasset($assetid);
        if (!is_string($asset)) {
          $args[$t->ASSETNAME] = $asset[$t->ASSETNAME];
          $incnegs = false;
          $args[$t->FORMATTEDAMOUNT] =
            $this->format_asset_value($amount, $asset, $incnegs);
        } else {
          $args[$t->ASSETNAME] = $assetid;
          $args[$t->FORMATTEDAMOUNT] = $amount;
        }
      }
      $res[] = $args;
    }
    return $res;
  }

  // Remove a history item
  function removehistoryitem($time) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In removehistoryitem(): Bank not set";

    $key = $this->userhistorykey();
    $db->put("$key/$time", '');

    return false;
  }

  // Return the last coupon resulting from a spend.
  // Clear the coupon store, so you can only get the coupon once.
  function getcoupon() {
    $ssl = $this->ssl;
    $privkey = $this->privkey;

    $coupon = $this->coupon;
    $this->coupon = false;
    return $ssl->privkey_decrypt($coupon, $privkey);
  }

  // Get the inbox contents.
  // Returns an error string, or an array of inbox entries, indexed by
  // their timestamps:
  //
  //   array($time => array(array($t->REQUEST => $request
  //                              $t->ID => $fromid,
  //                              $t->TIME => $time,
  //                              $t->MSGTIME => $msgtime,
  //                              $t->ASSET => $assetid,
  //                              $t->ASSETNAME => $assetname,
  //                              $t->AMOUNT => $amount,
  //                              $t->FORMATTEDAMOUNT => $formattedamount,
  //                              $t->NOTE => $note),
  //                        ...,
  //                        $t->MSG => $msg),
  //          ...)
  //
  // Where $request is $t->SPEND, $t->SPENDACCEPT, or $t->SPENDREJECT,
  // $fromid is the ID of the sender of the inbox entry,
  // $time is the timestamp from the bank on the inbox entry,
  // $msgtime is the timestamp in the sender's message,
  // $assetid & $assetname describe the asset being transferred,
  // $amount is the amount of the asset being transferred, as an integer,
  // $formattedamount is the amount as a decimal number with the scale
  // and precision applied,
  // $note is the note that came from the sender,
  // $msg is the raw inbox message, included only if $includeraw
  // There will usually be two entries for a SPEND inbox entry, the SPEND
  // and the corresponding TRANFEE.
  // SPENDACCEPT and SPENDREJECT entries will be by themselves.
  function getinbox($includeraw=false) {
    $db = $this->db;

    if (!$this->current_bank()) return "In getinbox(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getinbox_internal();
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function getinbox_internal($includeraw=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    $err = $this->sync_inbox();
    if ($err) return $err;

    $res = array();
    $key = $this->userinboxkey();
    $inbox = $db->contents($key);
    foreach ($inbox as $time) {
      $msg = $db->get("$key/$time");
      $reqs = $parser->parse($msg);
      if (!$reqs) return "Inbox parsing error: $reqs";
      $items = array();
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "Inbox unpack error: $args";
        if (@$args[$t->TIME] && $args[$t->TIME] != $time) {
          return "Inbox message timestamp mismatch";
        }
        $args = $args[$t->MSG];
        $request = $args[$t->REQUEST];
        $item = array();
        $item[$t->REQUEST] = $request;
        $item[$t->ID] = $args[$t->CUSTOMER];
        $item[$t->TIME] = $time;
        $item[$t->MSGTIME] = $args[$t->TIME];
        $item[$t->NOTE] = @$args[$t->NOTE];
        if ($request == $t->SPEND || $request == $t->TRANFEE) {
          $assetid = @$args[$t->ASSET];
          $amount = @$args[$t->AMOUNT];
          $asset = $this->getasset($assetid);
          $item[$t->ASSET] = $assetid;
          $item[$t->AMOUNT] = $amount;
          if (!is_string($asset)) {
            $item[$t->ASSETNAME] = $asset[$t->ASSETNAME];
            $incnegs = ($args[$t->CUSTOMER] != $this->bankid);
            $item[$t->FORMATTEDAMOUNT] =
              $this->format_asset_value($amount, $asset, $incnegs);
          }
        } elseif ($request == $t->SPENDACCEPT || $request == $t->SPENDREJECT) {
          // Pull in data from outbox to get amounts
        } else {
          return "Bad request in inbox: $request";
        }
        $items[] = $item;
      }
      if ($includeraw) $items[$t->MSG] = $msg;
      $res[$time] = $items;
    }

    return $res;
  }

  // Synchronize the current customer inbox with the current bank.
  // Return a string on error or false on success.
  // Assumes that there IS a current user and bank.
  // Does no database locking.
  function sync_inbox() {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $parser = $this->parser;
    $server = $this->server;

    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getinbox";
    $msg = $this->custmsg($t->GETINBOX, $bankid, $req);
    $bankmsg = $server->process($msg);
    
    $reqs = $parser->parse($bankmsg);
    if (!$reqs) return "While parsing getinbox return message: " . $parser->errmsg;
    $inbox = array();
    $times = array();
    $storagefees = array();
    $last_time = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While matching getinbox return: $args";
      $bankmsg = $parser->get_parsemsg($req);
      $request = $args[$t->REQUEST];
      if ($request == $t->ATGETINBOX) {
        $retmsg = $parser->get_parsemsg($args[$t->MSG]);
        if (trim($retmsg) != trim($msg)) return "getinbox return doesn't wrap message sent";
        $last_time = false;
      } elseif ($request == $t->INBOX) {
        $time = $args[$t->TIME];
        if (@$inbox[$time]) return "getinbox return included multiple entries for time: $time";
        $inbox[$time] = $bankmsg;
        $last_time = $time;
      } elseif ($request == $t->ATTRANFEE) {
        if (!$last_time) return "In getinbox return: @tranfee not after inbox";
        $inbox[$last_time] .= ".$bankmsg";
      } elseif ($request == $t->TIME) {
        $times[] = $args[$t->TIME];
      } elseif ($request == $t->STORAGEFEE) {
        $assetid = $args[$t->ASSET];
        $storagefees[$assetid] = $bankmsg;
      } elseif ($request != $t->COUPONNUMBERHASH) {
        return "Unknown request in getinbox return: $request";
      }
    }

    $key = $this->userinboxkey();
    $keys = $db->contents($key);
    foreach ($keys as $time) {
      $inmsg = @$inbox[$time];
      if ($inmsg) {
        $msg = $db->get("$key/$time");
        if ($msg != $inmsg) return "Inbox mismatch at time: $time";
        unset($inbox[$time]);
      } else {
        $db->put("$key/$time", '');
      }
    }
    foreach ($inbox as $time => $msg) {
      $db->put("$key/$time", $msg);
    }
    foreach ($storagefees as $assetid => $storagefee) {
      $key = $this->userstoragefeekey($assetid);
      $db->put($key, $storagefee);
    }
    if (count($times) > 0) {
      $db->put($this->usertimekey(), implode(',', $times));
    }
  }

  // Process the inbox contents.
  // $directions is an array of items of the form:
  //
  //  array($t->TIME => $time,
  //        $t->REQUEST => $request,
  //        $t->NOTE => $note,
  //        $t->ACCOUNT => $acct)
  //
  // where $time is a timestamp in the inbox,
  // $request is $t->SPENDACCEPT or $t->SPENDREJECT, or omitted for
  // processing an accept or reject from a former spend recipient,
  // $note is the note to go with the accept or reject, and
  // $acct is the account into which to transfer the funds (default: main).

  function processinbox($directions) {
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In processinbox(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $parser->verifysigs(false);

    $lock = $db->lock($this->userreqkey());
    $res = $this->processinbox_internal($directions, false);
    $db->unlock($lock);

    $parser->verifysigs(true);

    if ($res) $this->forceinit();

    return $res;
  }

  function processinbox_internal($directions, $recursive) {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    $inbox = $this->getinbox_internal($this->keephistory);
    $outbox = $this->getoutbox_internal($this->keephistory);
    $balance = $this->getbalance_internal(true, false);

    $timelist = '';
    $deltas = array(); // array($acct => array($asset => $delta, ...), ...)
    $outbox_deletions = array(); // array($timestamp, ...)

    $msg = '';
    $msgs = array();

    $history = '';
    $hist = '';

    $charges = array();

    foreach ($directions as $dir) {
      $time = $dir[$t->TIME];
      $request = @$dir[$t->REQUEST];
      $note = @$dir[$t->NOTE];
      $acct = @$dir[$t->ACCT];
      if (!$acct) $acct = $t->MAIN;

      if ($timelist) $timelist .= '|';
      $timelist .= $time;

      $ins = $inbox[$time];
      if (!$ins) return "No inbox entry for time: $time";

      $in = $ins[0];
      $fee = @$ins[1];        // will need generalization when I add multiple fees
      $inmsg = $ins[$t->MSG];

      $trans = $this->gettime();

      $inreq = $in[$t->REQUEST];
      if ($inreq == $t->SPEND) {
        $id = $in[$t->ID];
        $assetid = $in[$t->ASSET];
        $msgtime = $in[$t->MSGTIME];
        $amount = $in[$t->AMOUNT];
        if ($msg != '') $msg .= '.';
        if ($request == $t->SPENDACCEPT) {
          $this->do_storagefee($charges, $amount, $msgtime, $trans, $assetid);
          $deltas[$acct][$assetid] =
            bcadd(@$deltas[$acct][$assetid], $amount);
          $smsg = $this->custmsg($t->SPENDACCEPT, $bankid, $msgtime, $id, $note);
          $msgs[$smsg] = true;
          $msg .= $smsg;
          if ($inmsg) $hist .= ".$smsg.$inmsg";
        } elseif ($request == $t->SPENDREJECT) {
          if ($fee) {
            $deltas[$acct][$fee[$t->ASSET]] =
              bcadd(@$deltas[$acct][$fee[$t->ASSET]], $fee[$t->AMOUNT]);
          }
          $smsg = $this->custmsg($t->SPENDREJECT, $bankid, $msgtime, $id, $note);
          $msgs[$smsg] = true;
          $msg .= $smsg;
          if ($inmsg) $hist .= ".$smsg.$inmsg";
        } else {
          return "Illegal request for spend: $request";
        }
      } elseif ($inreq == $t->SPENDACCEPT || $inreq == $t->SPENDREJECT) {
        $msgtime = $in[$t->MSGTIME];
        $out = $outbox[$msgtime];
        if (!$out) return "Can't find outbox for $inreq at time $msgtime";
        $outbox_deletions[] = $msgtime;
        $outspend = $out[0];
        $outfee = $out[1];      // change when we have more than one fee
        if ($inreq == $t->SPENDREJECT) {
          // For rejected spends, we get our money back
          $assetid = $outspend[$t->ASSET];
          $amount = $outspend[$t->AMOUNT];
          $this->do_storagefee($charges, $amount, $msgtime, $trans, $assetid);
          $deltas[$acct][$assetid] = bcadd(@$deltas[$acct][$assetid], $amount);
          // And we have to pay for storage on the amount.
        } elseif ($outfee) {
          // For accepted spends, we get our tranfee back
          $deltas[$t->MAIN][$outfee[$t->ASSET]] =
            bcadd(@$deltas[$t->MAIN][$outfee[$t->ASSET]], $outfee[$t->AMOUNT]);
        }
        $outmsg = $out[$t->MSG];
        if ($outmsg) $hist .= ".$inmsg.$outmsg";
      } else {
        return "Unrecognized inbox request: $inreq";
      }
    }

    $pmsg = $this->custmsg($t->PROCESSINBOX, $bankid, $trans, $timelist);
    $msgs[$pmsg] = true;

    if ($msg) $msg = "$pmsg.$msg";
    else $msg = $pmsg;

    if ($this->keephistory) $history = "$pmsg$hist";

    $acctbals = array();

    // Compute fees for new balance files
    $fees = $this->getfees();
    if (is_string($fees)) return $fees;
    $tranfee = $fees[$t->TRANFEE];
    $feeasset = $tranfee[$t->ASSET];
    foreach ($deltas as $acct => $amounts) {
      foreach ($amounts as $asset => $amount) {
        $oldamount = @$balance[$acct][$asset][$t->AMOUNT];
        if (bccomp($oldamount, 0) != 0) {
          $oldtime = $balance[$acct][$asset][$t->TIME];
          $this->do_storagefee($charges, $oldamount, $oldtime, $trans, $asset);
          $balance[$acct][$asset][$t->AMOUNT] = $oldamount;
        }
        if ((!$oldamount) && !($oldamount==="0")) {
          $deltas[$t->MAIN][$feeasset] = bcsub($deltas[$t->MAIN][$feeasset], 1);
        }
      }
    }

    // Create balance, outboxhash, and balancehash messages
    foreach ($deltas as $acct => $amounts) {
      foreach ($amounts as $asset => $amount) {
        $oldamount = @$balance[$acct][$asset][$t->AMOUNT];
        $amount = bcadd($oldamount, $amount);
        $balmsg = $this->custmsg($t->BALANCE, $bankid, $trans, $asset, $amount, $acct);
        $msgs[$balmsg] = true;
        $acctbals[$acct][$asset] = $balmsg;
        $msg = $msg . ".$balmsg";
      }
    }

    if (count($outbox_deletions) > 0) {
      $outboxhash = $this->outboxhashmsg($trans, false, $outbox_deletions);
      $msgs[$outboxhash] = true;
      $msg = $msg . ".$outboxhash";
    } else $outboxhash = false;

    $balancehash = $this->balancehashmsg($trans, $acctbals);
    $msgs[$balancehash] = true;
    $msg = $msg . ".$balancehash";

    // Add storage and fraction messages
    $fracmsgs = array();
    foreach ($charges as $assetid => $assetinfo) {
      $percent = @$assetinfo['percent'];
      if ($percent) {
        $storagefee = $assetinfo['storagefee'];
        $fraction = $assetinfo['fraction'];
        $storagefeemsg = $this->custmsg($t->STORAGEFEE, $bankid, $trans, $assetid, $storagefee);
        $msgs[$storagefeemsg] = true;
        $fracmsg = $this->custmsg($t->FRACTION, $bankid, $trans, $assetid, $fraction);
        $msgs[$fracmsg] = true;
        $msg .= ".$storagefeemsg.$fracmsg";
        $fracmsgs[$assetid] = $fracmsg;
      }
    }

    // Send request to server
    $msg = $server->process($msg);

    // Validate return from server
    $reqs = $parser->parse($msg, true);
    if (!$reqs) return "Can't parse bank return from processinbox: $msg";
    $args = $this->match_bankreq($reqs[0], $t->ATPROCESSINBOX);
    if (is_string($args)) {
      $args = $this->match_bankreq($reqs[0]);
      if (is_string($args)) {
        if (!$recursive) {

          $parser->verifysigs(true);

          // Force reload of balances and outbox
          if ($err = $this->forceinit()) return $err;
          // Force reload of assets
          foreach ($charges as $assetid => $assetinfo) {
            $this->reload_asset_p($assetid);
          }

          $parser->verifysigs(false);

          return $this->processinbox_internal($directions, true);
        }
        return "Error from processinbox request: $args";
      }
      return "Processinbox request returned unknown message type: " . $request;
    }

    foreach ($reqs as $req) {
      $msg = $parser->get_parsemsg($req);
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "Error in processinbox response: $args";
      $m = $args[$t->MSG];
      if (!$m) return "No wrapped message in processinbox return: $msg";
      $m = trim($parser->get_parsemsg($m));
      if (!$msgs[$m]) return "Returned message wasn't sent: '$m'";
      if (is_string($msgs[$m])) return "Duplicate returned message: '$m'";
      $msgs[$m] = $msg;
    }

    foreach ($msgs as $m => $msg) {
      if ($msg === true) return "Message not returned from processinbox: $m";
    }

    // Commit to database
    foreach ($acctbals as $acct => $bals) {
      foreach ($bals as $asset => $balmsg) {
        $db->put($this->userbalancekey($acct, $asset), $msgs[$balmsg]);
      }
    }

    foreach($fracmsgs as $assetid => $fracmsg) {
      $key = $this->userfractionkey($assetid);
      $db->put($key, $msgs[$fracmsg]);
    }

    if ($outboxhash) {
      foreach($outbox_deletions as $outbox_time) {
        $db->put($this->useroutboxkey($outbox_time), '');
      }
      $db->put($this->useroutboxhashkey(), $msgs[$outboxhash]);
    }

    $db->put($this->userbalancehashkey(), $msgs[$balancehash]);

    if ($history) {
      $key = $this->userhistorykey();
      $db->put("$key/$trans", $history);
    }

    return false;
  }

  // Tell server to move storage fees to inbox
  // You need to call getinbox to see the new data (via its call to sync_inbox).
  function storagefees() {
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In storagefees(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->storagefees_internal();
    $db->unlock($lock);

    return $res;
  }

  function storagefees_internal() {
    $t = $this->t;
    $bankid = $this->bankid;
    $server = $this->server;

    $req = $this->getreq();
    $msg = $this->custmsg($t->STORAGEFEES, $bankid, $req);

    $bankmsg = $server->process($msg);

    $args = $this->unpack_bankmsg($bankmsg);
    if (is_string($args)) return "Server error: $args";
    $request = $args[$t->REQUEST];
    if ($request != $t->ATSTORAGEFEES) return "Unknown response type: $request";

    return false;
  }

  // Add storage fee for $amount/$msgtime to $charges[$assetid]['storagefee']
  // and set $charges[$assetid]['fraction'] to the fractional balance.
  function do_storagefee(&$charges, &$amount, $msgtime, $time, $assetid) {
    $u = $this->u;

    if (bccomp($amount, 0) > 0) {
      $assetinfo = @$charges[$assetid];
      if (!$assetinfo) {
        $assetinfo = array();
        $percent = $this->storageinfo($assetid, $fraction, $fractime);
        if ($percent) {
          $digits = $u->fraction_digits($percent);
          if ($fraction) {
            $fracfee = $u->storagefee($fraction, $fractime, $time, $percent, $digits);
          } else $fracfee = 0;
          $assetinfo['percent'] = $percent;
          $assetinfo['fraction'] = bcsub($fraction, $fracfee, $digits);
          $assetinfo['storagefee'] = $fracfee;
          $assetinfo['digits'] = $digits;
        }
        $charges[$assetid] = $assetinfo;
      }
      $percent = @$assetinfo['percent'];
      if ($percent) {
        $digits = $assetinfo['digits'];
        $fee = $u->storagefee($amount, $msgtime, $time, $percent, $digits);
        $storagefee = bcadd($assetinfo['storagefee'], $fee, $digits);
        $assetinfo['storagefee'] = $storagefee;
        $amount = bcsub($amount, $fee, $digits);
        $fraction = $assetinfo['fraction'];
        $u->normalize_balance($amount, $fraction, $digits);
        $assetinfo['fraction'] = $fraction;
        $charges[$assetid] = $assetinfo;
      }
    }
  }

  // Get the outbox contents.
  // Returns an error string or the outbox contents as an array of
  // of the form:
  //
  //   array($time => array(array($t->REQUEST => $request,
  //                              $t->TIME => $time,
  //                              $t->ID => $recipientid,
  //                              $t->NOTE => $note,
  //                              $t->ASSET => $assetid,
  //                              $t->ASSETNAME => $assetname,
  //                              $t->AMOUNT => $amount,
  //                              $t->FORMATTEDAMOUNT => formattedamount),
  //                        ...),
  //         ...)
  //
  // $time is the timestamp of the outbox entry
  // $request is $t->SPEND, $t->TRANFEE, or $t->COUPONENVELOPE
  // $recipientid is the recipient for spend, or omitted for tranfee
  // $assetid is the ID of the asset transferred
  // $assetname is the name of $assetid
  // $amount is the amount transferred
  // $formattedamount is $amount formatted for output
  // $note is the transfer note, omitted for tranfee
  //
  // If $request is $t->COUPONENVELOPE, then $t->COUPON indexes the coupon itself,
  // as text, and the rest of the fields are unpopulated.
  function getoutbox() {
    $db = $this->db;

    if (!$this->current_bank()) return "In getoutbox(): Bank not set";
    if ($err = $this->init-bank-accts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getoutbox_internal();
    $db->unlock($lock);

    return $res;
  }

  function getoutbox_internal($includeraw=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    $res = array();
    $key = $this->useroutboxkey();
    $outbox = $db->contents($key);
    foreach ($outbox as $time) {
      $msg = $db->get("$key/$time");
      $reqs = $parser->parse($msg, true);
      $items = array();
      if (!$reqs) return "In getoutbox, parse error: " . $parser->errmsg;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return $args;
        $request = $args[$t->REQUEST];
        if ($request != $t->COUPONENVELOPE) {
          $args = $args[$t->MSG];
          $request = $args[$t->REQUEST];
          if ($args[$t->TIME] != $time) {
            return "Outbox message timestamp mismatch";
          }
        }
        $item = array();
        $item[$t->REQUEST] = $request;
        $item[$t->TIME] = $time;
        $incnegs = false;
        if ($request == $t->SPEND) {
          $item[$t->ID] = $args[$t->ID];
          $item[$t->NOTE] = @$args[$t->NOTE];
          $incnegs = ($args[$t->ID] != $this->bankid);
        } elseif ($request == $t->TRANFEE) {
          // Nothing special to do here
        } elseif ($request == $t->COUPONENVELOPE) {
          $coupon = $args[$t->ENCRYPTEDCOUPON];
          if ($coupon) {
            $coupon = $this->ssl->privkey_decrypt($coupon, $this->privkey);
            $args = $this->unpack_bankmsg($coupon, $t->COUPON);
            if (is_string($args)) $coupon = "Coupon malformed: $coupon";
            else {
              $url = $args[$t->BANKURL];
              $coupon_number = $args[$t->COUPON];
              $coupon = "[$url, $coupon_number]";
            }
            $item[$t->COUPON] = $coupon;
          }
        } else {
          return "Bad request in outbox: $request";
        }
        $assetid = $args[$t->ASSET];
        $amount = $args[$t->AMOUNT];
        if ($assetid) {
          $asset = $this->getasset($assetid);
          $item[$t->ASSET] = $assetid;
          $item[$t->AMOUNT] = $amount;
          if (!is_string($asset)) {
            $item[$t->ASSETNAME] = $asset[$t->ASSETNAME];
            $item[$t->FORMATTEDAMOUNT] =
              $this->format_asset_value($amount, $asset, $incnegs);
          }
        }
        $items[] = $item;
        if ($includeraw) $items[$t->MSG] = $msg;
      }
      $res[$time] = $items;
    }

    uksort($res, 'bccomp');
    return $res;
  }

  // Redeem a coupon
  // If successful, add an inbox entry for the coupon spend and return false.
  // If fails, return error message.
  // Needs an option to process the coupon, intead of just adding it to
  // the inbox.
  function redeem($coupon) {
    $t = $this->t;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    $pubkey = $this->pubkeydb->get($bankid);
    if (!$pubkey) return "Can't get bank public key";
    
    $coupon = $ssl->pubkey_encrypt($coupon, $pubkey);
    $msg = $this->sendmsg($t->COUPONENVELOPE, $bankid, $coupon);
    $args = $this->unpack_bankmsg($msg, $t->ATCOUPONENVELOPE);
    if (is_string($args)) return "Redeem: $args";
    return false;
  }

  // End of API methods
||#

(defun passphrase-hash (passphrase)
  (sha1 (trim passphrase)))

(defmethod custmsg ((client client) &rest args)
  "Create a signed customer message.
   Takes an arbitrary number of args."
  (let* ((id (id client))
         (parser (parser client))
         (privkey (privkey client))
         (args (cons id args))
         (msg (apply 'makemsg parser args))
         (sig (sign msg privkey)))
    (trim (format nil "~a:~%~a" msg sig))))

(defmethod sendmsg ((client client) &rest args)
  "Send a customer message to the server.
   Takes an arbitrary number of args."
  (let ((server (server client))
        (msg (apply 'custmsg client args)))
    (process server msg)))

(defmethod client-unpack-bankmsg ((client client) msg &optional request bankid)
  "Unpack a bank message.
   Return a string if parse error or fail from bank.
   This is called via the $unpacker arg to utility->dirhash & balancehash."
  (let* ((parser (parser client))
         (reqs (parse parser msg))
         (req (car reqs))
         (args (match-bankreq client req request bankid)))
    (setf (getarg $UNPACK-REQS-KEY args) reqs) ;; save parse results
    args))

(defmethod match-bankreq ((client client) req &optional request bankid)
  "Unpack a bank message that has already been parsed."
  (unless bankid (setq bankid (bankid client)))
  (let* ((parser (parser client))
         (args (match-pattern parser req bankid)))
    (unless (equal (getarg $CUSTOMER args) bankid)
      (error "Return message not from bank"))
    (when (equal (getarg $REQUEST args) $FAILED)
      (error (format nil "Server error: ~a" (getarg $ERRMSG args))))
    (when (and request (not (equal (getarg $REQUEST args) request)))
      (error "Wrong return type from bank; sb: ~s, was: ~s"
             request (getarg $REQUEST args)))
    (let* ((msg (getarg $MSG args))
           (msgargs (and msg (match-pattern parser (getarg $MSG args)))))
      (when msgargs
        (let ((msgargs-bankid (getarg $BANKID msgargs)))
          (when (and msgargs-bankid (not (equal msgargs-bankid bankid)))
            (error "While matching bank-wrapped msg: bankid mismatch")))
        (setf (getarg $MSG args) msgargs)))
    args))

(defmethod client-storage-info ((client client) assetid)
  "Get the values necessary to compute the storage fee.
   Returns three values:
    1) percent - The storage fee
    2) fraction - the fraction balance for assetid
    3) fractime - the time of the fraction"
  (let* ((db (db client))
         (asset (or (getasset client assetid) (return-from client-storage-info 0)))
         (issuer (asset-issuer asset))
         (percent (asset-percent asset)))
    (cond ((equal issuer (id client)) 0)
          ((or (not percent) (eql 0 (bccomp percent 0))) 0)
          (t (let* ((key (userfractionkey client assetid))
                    (msg (db-get db key)))
               (if msg
                   (let ((args (client-unpack-bankmsg client msg $ATFRACTION)))
                     (setq args (getarg $MSG args))
                     (values percent (getarg $AMOUNT args) (getarg $TIME args)))
                   percent))))))

(defun pubkeykey (id)
  (append-db-keys $PUBKEY id))

(defmethod bankkey ((client client) &optional prop (bankid (bankid client)))
  (let ((key (append-db-keys $BANK bankid)))
    (if prop
        (append-db-keys key prop)
        key)))

(defmethod bankprop ((client client) prop &optional (bankid (bankid client)))
  (db-get (db client) (bankkey client prop bankid)))


(defmethod assetkey ((client client) &optional assetid)
  (let ((key (bankkey client $ASSET)))
    (if assetid
        (append-db-keys key assetid )
        key)))

(defmethod assetprop ((client client) assetid)
  (db-get (db client) (assetkey client assetid)))

(defmethod tranfeekey ((client client))
  (bankkey client $TRANFEE))

(defmethod tranfee ((client client))
  (db-get (db client) (tranfeekey client)))

(defmethod regfee-key ((client client))
  (bankkey client $REGFEE))

(defmethod regfee ((client client))
  (db-get (db client) (regfee-key client)))

(defmethod userbankkey ((client client) &optional prop (bankid (bankid client)))
  (let ((key (append-db-keys $ACCOUNT (id client) $BANK bankid)))
    (if prop
        (append-db-keys key prop)
        key)))

(defmethod userbankprop ((client client) &optional prop (bankid (bankid client)))
  (db-get (db client) (userbankkey client prop bankid)))

(defmethod userreqkey ((client client) &optional (bankid (bankid client)))
  (userbankkey client $REQ bankid))

(defmethod userreq ((client client) &optional (bankid (bankid client)))
  (db-get client (userreqkey client bankid)))

(defmethod usertimekey ((client client))
  (userbankkey client $TIME))

(defmethod userfractionkey ((client client) &optional assetid)
  (let ((key (userbankkey client $FRACTION)))
    (if assetid
        (append-db-keys key assetid)
        key)))

(defmethod userstoragefeekey ((client client) &optional assetid)
  (let ((key (userbankkey client $STORAGEFEE)))
    (if assetid
        (append-db-keys key assetid)
        key)))

(defmethod userbalancekey ((client client)  &optional acct assetid)
  (let ((key (userbankkey client $BALANCE)))
    (cond (acct
           (setq key (append-db-keys key acct))
           (if assetid
               (append-db-keys key assetid)
               key))
          (t key))))

(defmethod userbalance ((client client) acct assetid)
  (userbalanceandtime client acct assetid))

(defmethod userbalanceandtime ((client client) acct assetid)
  "Returns two values: the balance and its time"
  (when (null acct) (setq acct $MAIN))
  (let* ((msg (db-get (db client) (userbalancekey client acct assetid))))
    (when msg
      (let ((args (client-unpack-bankmsg client msg $ATBALANCE)))
        (setq args (getarg args $MSG))
        (values (getarg $AMOUNT args) (getarg $TIME args))))))

(defmethod useroutboxkey ((client client) &optional time)
  (let ((key (userbankkey client $OUTBOX)))
    (if time
        (append-db-keys key time)
        key)))

(defmethod useroutbox ((client client) time)
  (db-get (db client) (useroutboxkey client time)))

(defmethod useroutboxhashkey ((client client))
  (userbankkey client $OUTBOXHASH))

(defmethod useroutboxhash ((client client))
  (db-get (db client) (useroutboxhashkey client)))

(defmethod userbalancehashkey ((client client))
  (userbankkey client $BALANCEHASH))

(defmethod userbalancehash ((client client))
  (db-get (db client) (userbalancehashkey client)))

(defmethod userinboxkey ((client client))
  (userbankkey client $INBOX))

(defmethod contactkey ((client client) &optional otherid prop)
  (let ((key (userbankkey client $CONTACT)))
    (cond (otherid
           (setq key (append-db-keys key otherid))
           (if prop
               (append-db-keys key prop)
               key))
          (t key))))

(defmethod contactprop ((client client) otherid prop)
    (db-get (db client) (contactkey client otherid prop)))

(defmethod userhistorykey ((client client))
  (userbankkey client $HISTORY))

(defmethod format-asset-value ((client client) value assetid &optional (incnegs t))
  "Format an asset value from the asset ID or $this->getasset($assetid)"
  (let ((asset (if (stringp assetid)
                   (getasset assetid)
                   assetid)))
    (format-value
     value (asset-scale asset) (asset-precision asset) incnegs)))

(defmethod unformat-asset-value ((client client) formattedvalue assetid)
  "Unformat an asset value from the asset ID or $this->getasset($assetid)"
  (let ((asset (if (stringp assetid)
                   (getasset client assetid)
                   assetid)))
    (unformat-value formattedvalue (asset-scale asset))))

(defun fill-string (len &optional (char #\0))
  (make-string len :initial-element char))

(defun format-value (value scale precision &optional (incnegs t))
  ;; format an asset value for user printing
  (let ((sign 1)
        res)
    (when (and incnegs (< (bccomp value 0) 0))
      (setq value (bcadd value 1)
            sign -1))
    (cond ((and (eql 0 (bccomp scale 0)) (eql 0 (bccomp precision 0)))
           (setq res value))
          ((> (bccomp scale 0) 0)
           (let ((pow (bcpow 10 scale)))
             (wbp (scale)
               (setq res (bcdiv value pow))))
           (let ((dotpos (position #\. res)))
             (cond ((null dotpos)
                    (unless (eql 0 (bccomp precision 0))
                      (dotcat res "." (fill-string precision))))
                   (t
                    ;; Remove trailing zeroes
                    (let ((endpos (1- (length res))))
                      (loop
                         while (> endpos dotpos)
                         do
                           (unless (eql #\0 (aref res endpos)) (return))
                           (decf endpos))
                      (let* ((zeroes (- precision (- endpos dotpos)))
                             (zerostr (if (> zeroes 0) (fill-string zeroes) "")))
                        (setq res (strcat (subseq res 0 (1+ endpos)) zerostr)))))))))

    (when (and (eql 0 (bccomp value 0)) (< sign 0))
      (setq res (strcat "-" res)))

    ;; Insert commas
    (let* ((start 0)
           (dotpos (or (position #\. res) (length res)))
           (len dotpos))
      (when (eql #\- (aref res 0))
        (incf start)
        (decf len))
      (loop
         for pos = (+ len start -3)
         while (> pos 0)
         do
           (setq res (strcat (subseq res 0 pos) "," (subseq res pos)))
           (decf len 3)))

    res))

(defun unformat-value (formattedvalue scale)
  (let ((value (if (eql 0 (bccomp scale 0))
                   formattedvalue
                   (split-decimal
                    (wbp (scale) (bcmul formattedvalue (bcpow 10 scale)))))))
    (if (or (< (bccomp value 0) 0)
            (and (eql 0 (bccomp value 0))
                 (eql #\- (aref formattedvalue 0))))
      (bcsub value 1)
      value)))

(defmethod get-pubkey-from-server ((client client) id)
  "Send a t->ID command to the server, if there is one.
   Parse out the pubkey, cache it in the database, and return it.
   Return nil if there is no server or it doesn't know the id."
  (let* ((db (db client))
         (bankid (or (current-bank client)
                     (return-from get-pubkey-from-server nil)))
         (msg (sendmsg client $ID bankid id))
         (args (getarg $MSG (client-unpack-bankmsg client msg $ATREGISTER)))
         (pubkey (getarg $PUBKEY args))
         (pubkeykey (pubkeykey id)))
    (when pubkey
      (db-put db pubkeykey pubkey)
      pubkey)))

(defmethod getreq ((client client))
  "Get a new request"
  (let ((db (db client))
        (key (userreqkey client)))
    (with-db-lock (db key)
      (setf (db-get db key) (bcadd (db-get db key) 1)))))

(defmethod client-gettime ((client client) &optional forcenew)
  "Get a timestamp from the server"
  (let ((db (db client))
        (bankid (bankid client))
        (key (usertimekey client)))
    (with-db-lock (db key)
      (cond (forcenew (setf (db-get db key) nil))
            (t
             (let ((times (db-get db key)))
               (when times
                 (setf times (explode #\, times)
                       (db-get db key) (cadr times))
                 (return-from client-gettime (car times)))))))
    (let ((req (getreq client)))
      (cond ((not req) nil)
            (t (let* ((msg (sendmsg client $GETTIME bankid req))
                      (args (client-unpack-bankmsg client msg $TIME)))
                 (getarg $TIME args)))))))

(defmethod syncreq ((client client))
  "Check once per instance that the local idea of the reqnum matches
   that at the bank.
   If it doesn't, clear the account information, so that init-bank-accts()
   will reinitialize.
   Eventually, we want to compare to see if we can catch a bank error."
  (let* ((db (db client))
         (key (userbankkey client $REQ))
         (reqnum (db-get db key)))
    (when (equal reqnum "-1") (setf (syncedreq-p client) t))
    (unless (syncedreq-p client)
      (let* ((bankid (bankid client))
             (msg (sendmsg client $GETREQ bankid))
             (args (client-unpack-bankmsg client msg $REQ))
             (newreqnum (getarg $REQ args)))
      (unless (equal reqnum newreqnum)
        (setq reqnum "-1")
        (let* ((balkey (userbalancekey client))
               (accts (db-contents db balkey)))
          (dolist (acct accts)
            (let* ((acctkey (append-db-keys balkey acct))
                   (assetids (db-contents db acctkey)))
              (dolist (assetid assetids)
                (setf (db-get db acctkey assetid) nil)))))
        (let* ((frackey (userfractionkey client))
               (assetids (db-contents db frackey)))
          (dolist (assetid assetids)
            (setf (db-get db frackey assetid) nil)))
        (let* ((outboxkey (useroutboxkey client))
               (outtimes (db-contents db outboxkey)))
          (dolist (outtime outtimes)
            (setf (db-get outboxkey outtime) nil)))
        (setf (db-get db (userbalancehashkey client)) nil
              (db-get db (useroutboxhashkey client)) nil)
        (setf (syncedreq-p client) t))))
    reqnum))

(defmethod forceinit ((client client))
  "Force a reinit of the client database for the current user"
  (let ((db (db client)))
    (setf (db-get db (userreqkey client)) "0"
          (syncedreq-p client) nil)
    (init-bank-accts client)))

(defun get-inited-hash (key hash &optional (creator 'make-equal-hash))
  "Get an object from a hash table, creating it if it's not there."
  (or (gethash key hash)
      (setf (gethash key hash) (funcall creator))))

(defmethod init-bank-accts ((client client))
  "If we haven't yet downloaded accounts from the bank, do so now.
   This is how a new client instance gets initialized from an existing
   bank instance."
  (let* ((db (db client))
         (id (id client))
         (bankid (bankid client))
         (parser (parser client))
         (reqnum (syncreq client)))

    (when (equal reqnum "-1")
      ;; Get $REQ
      (let* ((msg (sendmsg client $GETREQ bankid))
             (args (client-unpack-bankmsg client msg $REQ))
             (reqnum (bcadd (getarg $REQ args) 1)))

        ;; Get account balances
        (setq msg (sendmsg client $GETBALANCE bankid reqnum))
        (let ((reqs (parse parser msg t))
              (balances (make-equal-hash))
              (fractions (make-equal-hash))
              (balancehash nil))
          (dolist (req reqs)
            (setq args (match-bankreq client req))
            (let* ((request (getarg $REQUEST args))
                   (msgargs (getarg $MSG args))
                   (customer (and msgargs (getarg $CUSTOMER msgargs))))
              (when (and msgargs (not (equal customer id)))
                (error "Bank wrapped somebody else's (~a) message: ~s" customer msg))
              (cond ((equal request $ATBALANCE)
                     (unless (equal (getarg $REQUEST msgargs) $BALANCE)
                       (error "Bank wrapped a non-balance request with @balance"))
                     (let ((assetid
                            (or (getarg $ASSET msgargs)
                                (error "Bank wrapped balance missing asset ID")))
                           (acct (or (getarg $ACCT msgargs) $MAIN)))
                       (setf (gethash assetid (get-inited-hash acct balances))
                             (get-parsemsg req))))
                    ((equal request $ATBALANCEHASH)
                     (unless (equal (getarg $REQUEST msgargs) $BALANCEHASH)
                       (error "Bank wrapped a non-balancehash request with @balancehash"))
                     (setq balancehash (get-parsemsg req)))
                    ((equal request $ATFRACTION)
                     (unless (equal (getarg $REQUEST msgargs) $FRACTION)
                       (error "Bank wrapped a non-fraction request with @fraction"))
                     (let ((assetid
                            (or (getarg $ASSET msgargs)
                                (error "Bank wrapped fraction missing asset ID")))
                           (fraction (get-parsemsg req)))
                       (setf (gethash assetid fractions) fraction))))))
          ;; Get outbox
          (setq reqnum (bcadd reqnum 1)
                msg (sendmsg client $GETOUTBOX bankid reqnum))
          (let ((reqs (parse parser msg t))
                (outbox (make-equal-hash))
                (outboxhash nil)
                (outboxtime nil))
            (dolist (req reqs)
              (setq args (match-bankreq client req))
              (let* ((request (getarg $REQUEST args))
                     (msgargs (getarg $MSG args))
                     (customer (and msgargs (getarg $CUSTOMER msgargs))))
                (when (and msgargs (not (equal customer id)))
                  (error "Bank wrapped somebody else's (%a) message: ~%"
                         customer msg))
                (cond ((equal request $ATGETOUTBOX))
                      ((equal request $ATSPEND)
                       (unless (equal (getarg $REQUEST msgargs) $SPEND)
                         (error "Bank wrapped a non-spend request with @spend"))
                       (let ((time (getarg $TIME msgargs)))
                         (setf outboxtime time
                               (gethash time outbox) (get-parsemsg req))))
                      ((equal request $ATTRANFEE)
                       (unless (equal (getarg $REQUEST msgargs) $TRANFEE)
                         (error "Bank wrapped a non-tranfee request with @tranfee"))
                       (let* ((time (getarg $TIME msgargs))
                              (msg (or (gethash time outbox)
                                       (error "No spend message for time: ~s" time))))
                         (setf (gethash time outbox)
                               (append-db-keys msg (get-parsemsg req)))))
                      ((equal request $ATOUTBOXHASH)
                       (unless (equal (getarg $REQUEST msgargs) $OUTBOXHASH)
                         (error "Bank wrapped a non-outbox request with @outboxhash"))
                       (setq outboxhash (get-parsemsg req)))
                      ((equal request $COUPONENVELOPE)
                       (unless outboxtime
                         (error "Got a coupon envelope with no outboxtime"))
                       (let ((msg (or (gethash outboxtime outbox)
                                      (error "No spend message for coupon envelope"))))
                         (setq msg (append-db-keys  msg (get-parsemsg req)))
                         (setf (gethash outboxtime outbox) msg
                               outboxtime nil)))
                      (t
                       (error "While processing getoutbox: bad request: ~s"
                              request)))))

            (when (and (not (equal id bankid))
                       (> (hash-table-count outbox) 0)
                       (not outboxhash))
              (error "While procesing getoutbox: outbox items but no outboxhash"))

            ;; All is well. Write the data
            (loop
               for acct being the hash-key using (hash-value assets) of balances
               do
               (loop
                  for assetid being the hash-key using (hash-value msg) of assets
                  do
                  (setf (db-get db (userbalancekey client acct assetid)) msg)))

            (loop
               for assetid being the hash-key using (hash-value fraction)
               of fractions
               do
               (setf (db-get db (userfractionkey client assetid)) fraction))

            (loop
               for time being the hash-key using (hash-value msg) of outbox
               do
               (setf (db-get db (useroutboxkey client time)) msg))

            (setf (db-get db (userbalancehashkey client)) balancehash
                  (db-get db (useroutboxhashkey client)) outboxhash
                  (db-get db (userreqkey client)) reqnum)))))))

(defmethod unpacker ((client client))
  #'(lambda (msg) (client-unpack-bankmsg client msg)))

(defmethod balancehashmsg ((client client) time acctbals)
  (let* ((db (db client))
         (bankid (bankid client)))
    (multiple-value-bind (hash hashcnt)
        (balancehash db (unpacker client) (userbalancekey client) acctbals)
      (custmsg client $BALANCEHASH bankid time hashcnt hash))))

(defmethod outboxhashmsg ((client client) transtime &optional newitem removed-times)
  (let ((db (db client))
        (bankid (bankid client)))
    (multiple-value-bind (hash hashcnt)
        (dirhash db (unpacker client) newitem removed-times)
      (custmsg client $OUTBOXHASH bankid transtime hashcnt hash))))

;; Web client session support

(defun newsessionid ()
  "Return a new, random, session ID"
  (let ((res (bin2hex (urandom-bytes 20))))
    (if (< (length res) 40)
        (strcat (fill-string (- 40 (length res))) res)
        res)))

(defun xorcrypt (key string)
  "xor hashed copies of KEY with STRING and return the result.
   This is a really simple encryption that only really works if
   KEY is known to be random, e.g. the output of (newsessionid)."
  (let* ((key (hex2bin (sha1 key) :string))
         (idx 0)
         (keylen (length key))
         (len (length string)))
    (with-output-to-string (s)
      (dotimes (i len)
        (write-char (code-char
                     (logxor (char-code (aref key idx))
                             (char-code (aref string i))))
                    s)
        (incf idx)
        (when (>= idx keylen)
          (setq idx 0
                key (hex2bin (sha1 key) :string)
                keylen (length key)))))))

(defmethod usersessionkey ((client client))
  "Return the database key for the user's session hash."
  (append-db-keys $ACCOUNT (id client) $SESSION))

(defmethod usersessionhash ((client client))
  "Return the user's session hash."
  (db-get (db client) (usersessionkey client)))

(defun sessionkey (sessionhash)
  "Return the database key for a session hash"
  (append-db-keys $SESSION sessionhash))

(defmethod session-passphrase ((client client) sessionid)
  "Return the passphrase corresponding to a session id"
  (let* ((db (db client))
         (passcrypt (or (db-get db (sessionkey (sha1 sessionid)))
                        (error "No passphrase for session"))))
    (xorcrypt sessionid passcrypt)))

(defmethod make-session ((client client) passphrase)
  "Create a new user session, encoding $passphrase with a new session id.
   Return the new session id.
   If the user already has a session stored with another session id,
   remove that one first."
  (let* ((db (db client))
         (sessionid (newsessionid))
         (passcrypt (xorcrypt sessionid passphrase))
         (usersessionkey (usersessionkey client)))
    (with-db-lock (db usersessionkey)
      (let ((oldhash (db-get db usersessionkey)))
        (when oldhash
          (setf (db-get db (sessionkey oldhash)) nil)))
      (let ((newhash (sha1 sessionid)))
        (setf (db-get db (sessionkey newhash)) passcrypt
              (db-get db usersessionkey) newhash)))
    sessionid))

(defmethod remove-session ((client client))
  "Remove the current user's session"
  (let* ((db (db client))
         (usersessionkey (usersessionkey client)))
    (with-db-lock (db usersessionkey)
      (let ((oldhash (db-get db usersessionkey)))
        (when oldhash
          (setf (db-get db (sessionkey oldhash)) nil
                (db-get db usersessionkey) nil))))))

(defmethod user-preference-key (client pref)
  "Preferences"
  (append-db-keys $ACCOUNT (id client) $PREFERENCE pref))

(defmethod user-preference ((client client) pref)
  "Get or set a user preference.
   Include the $value to set."
  (let* ((db (db client))
         (key (user-preference-key client pref)))
    (db-get db key)))

(defmethod (setf user-preference) (value (client client) pref)
  (let* ((db (db client))
         (key (user-preference-key client pref)))
    (setf (db-get db key) value)))

(defmethod debugmsg ((client client) x)
  "Add a string to the debug output.
   Does NOT add a newline.
   Use var_export($val, true) to dump arrays"
  (let ((showprocess (showprocess client)))
    (when showprocess (funcall showprocess x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Connection to the server
;;;

(defclass serverproxy ()
  ((url :type string
        :initarg :url
        :accessor url)
   (client :type client
           :initarg client
           :accessor client)))

(defun post (url &optional parameters)
  (drakma:http-request url
                       :method :post
                       :parameters parameters
                       :form-data t
                       :close nil
                       :keep-alive t))

(defmethod process ((proxy serverproxy) msg)
  (let* ((url (url proxy))
         (client (client proxy)))

    ;; This is a kluge to get around versions of Apache that insist
    ;; on sending "301 Moved Permanently" for directory URLs that
    ;; are missing a trailing slash.
    ;; Drakma can likely handle this, but I'm just copying the PHP
    ;; code for now.
    (unless (eql #\/ (aref url (1- (length url))))
      (dotcat url "/"))

    (let* ((showprocess (showprocess client))
           (vars `(("msg" . ,msg))))

      (when showprocess
        (push '("debugmsgs" . "true") vars))

      (when showprocess
        (debugmsg client (format nil "<b>===SENT</b>: ~a~%"
                                 (trimmsg msg))))

      (let ((res (post url vars))
            (text nil))
        (when (and (> (length res) 2)
                   (equal "<<" (subseq res 0 2)))
          (let ((pos (search #.(format nil ">>~%") res)))
            (when pos
              (setq text (subseq res 2 (- pos 2))
                    res (subseq res (+ pos 3))))))
        (when (and text showprocess)
          (debugmsg client (format nil "<b>===SERVER SAID</b>: ~a" text)))
    
        (when showprocess
          (debugmsg client (format nil "<b>===RETURNED</b>: ~a~%"
                                   (trimmsg res))))

        res))))

(defun trimmsg (msg)
  (let* ((msg (remove-signatures msg))
         (tokens (mapcar 'cdr (tokenize msg)))
         (res ""))
    (dolist (token tokens)
      (cond ((characterp token) (dotcat res (string token)))
            ((ishex-p token) (dotcat res token))
            (t (dotcat res "<b>" token "</b>"))))
    res))

(defun ishex-p (str)
  (let ((len (length str)))
    (dotimes (i len t)
      (unless (position (aref str i) "0123456789abcdef")
        (return nil)))))

;; Look up a public key, from the client database first, then from the
;; current bank.
(defclass pubkeydb ()
  ((client :type client
           :initarg :client
           :accessor client)
   (db :type db
       :initarg :db
       :accessor db)))

(defvar *insidep* nil)

(defmethod db-get ((pubkeydb pubkeydb) id &rest more-keys)
  (assert (null more-keys) nil "PUBKEYDB takes only a single DB-GET key")
  (or (db-get (db pubkeydb) id)
      (and (not *insidep*)
           (let ((*insidep* t))
             (get-pubkey-from-server (client pubkeydb) id)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Copyright 2009 Bill St. Clair
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions
;;; and limitations under the License.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
