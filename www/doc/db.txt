Items in angle brackets are variables
Items not in angle brackets are literals
"--" comment to the end of the line
<dir>/ is a directory
<key>=<value> is a file named <key> with contents <value>
Items whose names end with "#" are sequence numbers.
name:<item> denotes an optional item, passed by position or name
Items in parens  are signed. Signature omitted here.

truledger-dbs/serverdb/
  time=(<serverid>,time,<time#>)  -- The global timestamp
  privkey=<privkey>   -- the private key. Maybe this shouldn't be in
                      -- the database, so it doesn't get backed up,
                      -- But once we have a stand-alone server, it
                      -- will need a passphrase to use
  tokenid=(<serverid>,tokenid,<tokenid>)  -- The assetid of the usage token asset
  regfee=(<serverid>,regfee,<serverid>,<time#>,<tokenid>,<amount>)
                   -- Usage tokens paid for registration
                   -- default: 10 (pubkey/<id> (2),
                                  account/<id>/(time, last, req, outboxhash),
                                  and a few for good luck)
  tranfee=(<serverid>,tranfee,<serverid>,<time#>,<tokenid>,<amount>)
                   -- Usage tokens paid for a transaction.
                   -- Returned when the transaction completes.
                   -- Given to recipient when he rejects a spend (anti-spam)
                   -- Default: 2 (inbox & outbox entry)
  fee/  -- permanent fees, paid for transactions of the given type
        -- Default: none
    spend=(<serverid>,fee,<serverid>,<time#>,spend,<assetid>,<amount>)[...]
    transfer=(<serverid>,fee,<serverid>,<time#>,transfer,<assetid>,<amount>)[...]
    asset=(<serverid>,fee,<serverid>,<time#>,asset,<assetid>,<amount>)[...]
  pubkey/  -- for fast lookup. Must verify that <id> = hash(<pubkey>)
    <id>=<pubkey>
  pubkeysig/
    <id>=(<serverid>,@register,(<id>,register,<serverid>,<pubkey>,name=<name>))
  data/
    <keyhash>=<id>,<data>
  asset/ -- Where the asset types are stored
    <assetid>=(<serverid>,@asset,(<id>,asset,<serverid>,<assetid>,<scale>,<precision>,<assetname>)).
              (<serverid>,@storage,(<id>,storage,<serverid>,<time#>,<assetid>,<percent>))
        -- The assetid is the sha1 hash of a comma-separated
        -- concatenation of <id>,<scale>,<precision>,<assetname>
        -- This makes an assetid impossible to forge, though there
        -- can be multiple assets with the same name. Customer beware.
        -- Note that because the assetid is unique, it can cross server boundaries.
        -- @storage fees are optional
        -- <percent> is a decimal number giving the percent charge per year
  coupon
    <couponhash>=(<serverid>,@spend,(<id>,spend,<serverid>,<time#>,coupon,<assetid>,<amount>,note:<note>))
  account/
    <id>/
      time=<time#>  -- 0 when no outstanding transaction, or the
                       <time#> for the next transaction. Will contain
                       <time#>,<time2#> after an "inbox" query.
      last=<time#>  -- The last used value of /account/<id>/time
      req=<req#>    -- starts at 0. New requests must have a higher number
      fraction/     -- fractional amounts due to storage fees
        <assetid>=(<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid>,<amount>))
      balancehash=(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<count>,<hash>))
      balance/
        <acct>/  -- "main" is the default acct name
          <assetid>=(<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid>,<amount>,acct:<acct>))
      outboxhash=(<serverid>,@outboxhash,(<id>,outboxhash,<serverid>,<time#>,<count>,<hash>))
      outbox/
        <time2#>=(<serverid>,@spend,(<id>,spend,<serverid>,<time2#>,<id2>,<assetid2>,<amount2>,note:<note2>)).
                 (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time2#>,<tokenid>,<amount2fee>))
        <time3#>=(<serverid>,@spend,(<id>,spend,<serverid>,<time3#>,<id3>,<assetid3>,<amount3>,note:<note3>)).
                 (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time3#>,<tokenid>,<amount3fee>))
      inbox/
        <time6#>=(<serverid>,inbox,<time6#>,(<id2>,spend|accept,<serverid>,<time2#>,<id>,note:<note22>))
        <time7#>=(<serverid>,inbox,<time7#>,(<id3>,spend|reject,<serverid>,<time3#>,<id>,note:<note32>))
        <time8#>=(<serverid>,inbox,<time8#>,(<id4>,spend,<serverid>,<time4#>,<id>,<assetid4>,<amount4>,note:<note4>)).
                 (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time4#>,<tokenid>,<amount4fee>))
        <time9#>=(<serverid>,inbox,<time9#>,(<id4>,spend,<serverid>,<time5#>,<id>,<assetid5>,<amount5>,note:<note5>)).
                 (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time5#>,<tokenid>,<amount9fee>)).
                 (<serverid>,couponnumberhash,<coupon>)
      storagefee/  -- accumulators for storage fees. <amount>s have fractions
        <assetid>=(<serverid>,storagefee,<serverid>,<time#>,<assetid>,<amount>)
      permission/
        <permission>=(<serverid>,@grant,(<id>,grant,<serverid>,<time#>,<toid>,<permission>,grant=grant))...
      vendacct=(<serverid>,@vendacct,(<id>,vendacct,<serverid>,<time#>,<acct>))
      defvend/
        <vend#>=(<serverid>,@defvend,(<id>,defvend,<serverid>,<time#>,<vend#>,expires=<time#>,note=<note>).
               (<id>,vendin,<serverid>,<time#>,<vend#>,<assetid1>,<amount1>).
               (<id>,vendin,<serverid>,<time#>,<vend#>,<assetid2>,<amount2>).
               ...
               (<id>,vendin,<serverid>,<time#>,<vend#>,<assetidN>,<amountN>).
               (<id>,vendout,<serverid>,<time#>,<vend#>,<assetid-o1>,<amount-o1>).
               (<id>,vendout,<serverid>,<time#>,<vend#>,<assetid-o2>,<amount-o2>).
               ...
               (<id>,vendout,<serverid>,<time#>,<vend#>,assetid-oN>,<amount-oN>))
      vendpool/
        <assetid>=(<serverid>,spend,<serverid>,<time#>,<id>,<assetid>,<amount>)
      transaction/
        (<serverid>,@spend,(<id>,spend,<time#>,<id2>,<serverid>,<assetid>,<amount>,note:<note>))...
          or
        (<serverid,@processinbox,(<id>,processinbox,<serverid>,<time11#>,<time7#>|<time8#>|<time9#>)...


=== Transactions ===

Note that <serverid> is sent in almost all transactions. This guarantees
that the request is actually meant for that server. It also makes it
easy to notice if somebody steals the machine, but not the server's
private key passphrase. They will be able to resign all the database
contents, but since all the customer-signed data contains the original
serverid, a customer will notice the change, and be able to prove it.
The server checks, for all request, that the <serverid> sent matches. I
won't repeat this requirement below.


Get serverid
----------
  Customer sends:

(<id>,serverid,<pubkey>)

  If <id> is the public key ID for <pubkey>, server returns:

(<serverid>,register,<serverid>,<pubkey>,name=<name>)

  The <serverid> is required for the other requests, and the server's
  public key, to validate them. So a new customer will need to do this
  first.

  If there's a mismatch, server returns:

(<serverid>,failed,(<id>,serverid,<pubkey>),errcode:<errcode>,reason:<reason>)

  Which the client will be unable to parse, not knowing the server's public key.

  In order to make this command possible to send without first
  generating a public key pair, you can use "0" for the <id>,
  anything, including blank, for the <pubkey>, and any non-blank
  string as the signature. E.g.:

(0,serverid,):0


Create account
--------------

  Customer sends:

(<id>,register,<serverid>,<pubkey>,name=<name>)

  If the id is new, matches the pubkey, the <serverid> is correct, the
  signature is OK, and the customer has enough usage tokens in his
  inbox (spending usage tokens to a new <id> is how the account
  directory is actually created), server adds a negative spend for the
  registration tokens to customer's inbox, and responds with:

(<serverid>,@register,(<id>,register,<serverid>,<pubkey>,name=<name>))

  This is the first time the server will have seen the customer's
  pubkey.  The parsing code notices these "id" messages, and verifies
  pubkey if unknown, before using it to verify the registration
  message itself.  Customer will need to process his inbox to transfer
  his introduction tokens, and the server's charges against them, to his
  balance. Servers can choose to put negative spends in your inbox to
  charge periodic fees. You usually won't be able to spend an asset
  to anyone but the asset issuer until you pay those fees. Servers can
  also choose to allow negative spends from any customer to
  another. This is a request for money, and can be denied like any
  other spend.

(<serverid>,failed,(<id>,register,<pubkey>),errcode:<errcode>,reason:<reason>)

  Note that pubkeys bigger than 4096 bits won't be accepted. Really
  big keys are a good way to DOS attack the server.

  Customer can append "couponenvelope" messages to the "register"
  message to make an initial deposit. These messages may contain
  the usage tokens necessary to fund the new account, plus other
  assets:

(<id>,register,<serverid>,<pubkey>,name=<name>).
(<id>,couponenvelope,<serverid>,<encrytped-coupon>)...

  Where <encrypted-coupon> is the following, encrypted to the server's
  public key.

(<serverid>,coupon,<serverurl>,<coupon>,<assetid>,<amount>,note:<note>)

  The server will append the normal couponenvelope response to the
  register response:

(<serverid>,@register,(<id>,register,<serverid>,<pubkey>,name=<name>)).
(<serverid>,@couponenvelope,(<id>,couponenvelope,<serverid>,<encrytped-coupon>))

Look up pubkey
--------------

  Customer sends:

(<id>,id,<serverid>,<id2>)

  Use 0 for <id2> to look up the server's key.
  If <id2> is registered, server responds with:

(<serverid>,@register,(<id2>,register,<serverid>,<pubkey>,name=<name>))

  If there is no such id, server responds with:

(<serverid>,failed,(<id>,id,<serverid>,<id2>),errcode:<errcode>,reason:<reason>)

  Note that only registered customers can ask for another customer's
  public key. Otherwise, the server won't know the public key with which
  to validate the request. Also note that this request can be replayed.
  The response is always the same, so what's the harm?


Get Req
-------

  Customer sends:

(<id>,getreq,<serverid>)

  Server returns:

(<serverid>,req,<id>,<req#>)

  Note that this request can be replayed. The customer needs to have
  some way of getting back in sync for requests. This is it.  It makes
  no changes to the server database, just returns the customer's most
  recent request <req#>.


Get timestamp
-------------

  Customer sends:

(<id>,gettime,<serverid>,<req#>)

  Server compares <req#> to /accounts/<id>/req. If <req#> is greater,
  server sets /account/<id>/req to <req#>, increments /time to <time#>,
  sets /account/<id>/time to <time#>, and returns:

(<serverid>,time,<id>,<time#>)

  Otherwise, server returns:

(<serverid>,failed,(<id>,gettime,<serverid>,<req#>),errcode:<errcode>,reason:<reason>)

  Note that this always creates a new <time#>, larger than any
  timestamp in the server. If the cusomter didn't use the last <time#>
  returned from this request, it is overwritten, and can no longer be
  used.

Get fees
--------

  Customer sends:

(<id>,getfees,<serverid>,<req#>,operation=<operation>)

  Server compares <req#> to /account/<id>/req. If <req#>
  is greater, server sets /account/<id>/req to <req#>,
  increments /time to <time#>, and returns /regfee,
  /tranfee, and /fee/<operation>, for all fee
  items if operation is not included.

(<serverid>regfee,<serverid>,<time#>,0,<amount>).
  (<serverid>,tranfee,<serverid>,<time#>,0,<amount>).
  (<serverid>,fee,<serverid>,<time#>,<operation>,<assetid>,<amount>).
  (<serverid>,fee,<serverid>,<time#>,<operation2>,assetid2>,<amount2>).
  ...
  (<serverid>,fee,<serverid>,<time#>,<operationN>,<assetidN>,<amountN>)

  Otherwise, server returns:

(<serverid>,failed,(<id>,getfees,<serverid>,<req#>,<operation>),errcode:<errcode>,reason:<reason>)


Set Fees
--------

  Customer sends:

(<serverid>,setfees,<time#>,<cnt#>).
(<serverid>,fee,spend,<time#>,<assetid>,<amount>)...
(<serverid>,fee,transfer,<time#>,<assetid>,<amount>)...
(<serverid>,fee,asset,<time#>,<assetid>,<amount>)...

  Server checks that the <time#> is equal to /account/<id>/time, that
  <cnt#> is the number of fee records passed, that the <time#> fields
  all match, and that the <assetid>s all name known assets. It replaces
  the fees at fee/ with the ones in the message, and returns:

(<serverid>,@setfees,(<serverid>,setfees,<time#>,<cnt#>))

  If there is an error, server returns:

(<serverid>,failed>,(<serverid>,setfees,<time#>,<cnt#>),errcode:<errcode>,reason:<reason>)


Spend
-----

  Customer sends the following. Second and subsequent balance items
  are for the fee assets. Customer can pick whatever accounts he likes
  for the fees to be taken from. The server figures out if it can make
  it work.

(<id>,spend,<serverid>,<time#>,<id2>,<assetid>,<amount>,note:<note>).
  (<id>,tranfee,<serverid>,<time#>,<tokenid>,<amount2fee>).
  (<id>,storagefee,<serverid>,<time#>,<assetid>,<storageamount>).
  (<id>,fee,<serverid>,<time#>,<operation>,<feeasset>,<feeamount>).
  (<id>,balance,<serverid>,<time#>,<assetid>,<amount>,acct:<acct>).
  (<id>,fraction,<serverid>,<time#>,<assetid>,<fractionamount>).
  (<id>,balance,<serverid>,<time#>,<assetid2>,<amount2>,acct:<acctN>).
  ...
  (<id>,balance,<serverid>,<time#>,<assetidN>,<amountN>,acct:<acctN>).
  (<id>,outboxhash,<serverid>,<time#>,<outboxcount>,<outboxhash>).
  (<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>)

  Server checks that the <time#> is equal to /account/<id>/time, that
  the balances match (after subtracting the spend amount & fees), and
  that the hashes match what the customer sent. If they match, server
  computes the item list below, stores it in the database in the
  directory /account/<id>/transaction, and returns:

(<serverid>,@spend,(<id>,spend,<time#>,<id2>,<serverid>,<assetid>,<amount>,note:<note>)).
  (<serverid>,@storagefee,(<id>,storagefee,<serverid>,<time#>,<assetid>,<storageamount>)).
  (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time#>,<tokenid>,<amount2fee>)).
  (<serverid>,@fee,(<id>,fee,<serverid>,<time#>,<operation>,<feeasset>,<feeamount>)).
  (<serverid>,@balance,(<id>,balance,<time#>,<serverid>,<assetid>,<amount>,acct:<acct>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid>,<amount>)).
  (<serverid>,@balance,(<id>,balance,<time#>,<serverid>,assetid2>,<amount2>,acct:<acct2>)).
  ...
  (<serverid>,@balance,(<id>,balance,<time#>,<serverid>,<assetidN>,<amountN>,acct:<acctN>)).
  (<serverid,@outboxhash,(<id>,outboxhash,<serverid>,<time#>,<outboxcount>,<outboxhash>)).
  (<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))

If they don't match, server returns:

(<serverid>,failed,(<id>,spend,<serverid>,<time#>,<id2>,<assetid>,<amount>,note:<note>),errcode:<errcode>,reason:<reason>)

  This is the first phase of the two-phase commit for spends.

  Note that there's an outbox hash and a balance hash. The outbox hash
  is the sha1 hash of the customer "spend"."tranfee" items,
  alphabetically sorted by timestamp, and tacked together with
  periods. The hash for a particular <acct>, is the sha1 hash of the
  customer "balance" items in that <acct>, alphabetically sorted by
  <assetid>, and tacked together with periods. If there is only one
  <acct>, the balancehash is that <acct>'s hash. If there is more than
  one <acct>, then the balance hash is the sha1 hash of a string made
  by tacking together the hash for each <acct>, sorted by <acct> and
  separated by periods. The two hashes also contain a count, which is
  the number of user items that participated in the hashing. This
  isn't strictly necessary, but it can help to identify problems if
  the client and server disagree on something.

  To commit the transaction, the customer countersigns the
  balancehash, and sends it back to the server:

(<id>,commit,(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>)))

  The server checks that <time#> matches the timestamp in the saved
  transaction. If it does the server sets /account/<id>/time to 0,
  stores the spend in /account/<id>/outbox/<time#> and
  /account/<id2>/inbox/<time#>, sets the
  /account/<id>/balance/<acct>/<assetid> to the balances from
  /account/<id>/transaction, udpates /account/<id>/outboxhash, and
  /account/<id>/balancehash with the signed hashes, and sends:

(<serverid>,@commit,(<id>,commit,(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))))

  If the server no longer has a record of the first phase of the
  transaction, it will send:

(<serverid>,failed,(<id>,commit,(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))),errcode:<errcode>,reason:<reason>)

  If the customer disagrees with the server's first response, he can rollback
  the transaction by sending:

(<id>,rollback,<serverid>,<time#>)

  The server removes the /account/<id>/transaction file, and responds
  with:

(<serverid>,@rollback,(<id>,rollback,<serverid>,<time#>))

  If the server charges non-refunable fees for spends, they must be
  included with the customer's spend message, and they will be
  included in the return message, signed with the same timestamp as
  the customer's spend message. <operation> in the "fee" items can be
  "spend" or "transfer", depending on whether the spend is to another
  customer or a self-spend that moves between accts. Non-refundable
  fees are retained by the server even if the recipient rejects the
  spend. They provide a steady source of revenue to pay for the server's
  operation. They will usually be small, at least for servers that want
  to attract cusomers.

  The refundable fees are stored in the outbox and included in the
  server response in case they change between the time the spend is
  initiated and when it is closed. Note that the server does NOT credit
  its own account with the refundable fees. Those are left in the
  outbox, pending acceptance or rejection of the spend. If accepted,
  the fees are credited back to the customer account. If the recipient
  rejects, they are credited to his account at rejection time. Hence,
  auditing the transaction fee asset requires looking at accounts,
  outbox items, and inbox items. spend|reject inbox items cancel out
  the fees in the corresponding outbox item. spend_accept inbox items
  do not.

Cancel Spend
------------

  Customer sends:

(<id>,spend|reject,<serverid>,<time#>,<id>,note:<note>)

  Server ensures that there is an outbox entry for <time#>, and that it
  has not been accepted or rejected by its recipient. Removes the
  inbox entry from the recipient, and adds an inbox entry to
  customer's inbox that looks just like the recipient rejected the
  spend, except that it's from the customer instead of the recipient.
  The customer can use processinbox on it just like any other rejected
  spend. The usage tokens paid for the spend are taken by the server,
  just like any other rejected spend. This discourages lots of
  cancelling of spends. Server returns:

(<serverid>,INBOX,<time2#>,(<id>,spend|cancel,<serverid>,<time#>,<id>,note:<note>))

  If there's no outbox entry for <time#>, or the recipient has already
  accepted or rejected the spend, server returns:

(<serverid>,failed,(<id>,spend|reject,<serverid>,<time#>,<id>,note:<note>),errcode:<errcode>,reason:<reason>)


Query Inbox
------------

  Customer sends:

(<id>,getinbox,<serverid>,<req#>)

  Server compares <req#> to /account/<id>/req. If <req#> is greater,
  server sets /account/<id>/req to <req#> and responds with contents of
  /account/<id>/inbox/, separated by periods. Server also sets
  /account/<id>/last to the highest of the timestamps in the inbox.

(<serverid>,@getinbox,(<id>,getinbox,<serverid>,<req#>).
  (<serverid>,inbox,<time6#>,(<id2>,spend|accept,<serverid>,<time2#>,note:<note22>)).
  (<serverid>,inbox,<time7#>,(<id3>,spend|reject,<serverid>,<time3#>,note:<note32>)).
  (<serverid>,inbox,<time8#>,(<id4>,spend,<serverid>,<time4#>,note:<note4>)).
  (<serverid>,@tranfee,(<id4>,tranfee,<serverid>,<time4#>,<tokenid>,<amount4fee>)).
  (<serverid>,inbox,<time9#>,(<id5>,spend,<serverid>,time5#>,note:<note5>)).
  (<serverid>,@tranfee,(<id5>,tranfee,<serverid>,<time5#>,<tokenid>,<amount5fee>)).
  (<serverid>,storagefee,<serverid>,<time10#>,<assetid>,<amount>).
  (<serverid>,storagefee,<serverid>,<time11#>,<assetid2>,<amount>)

  Otherwise, server sends:

(<serverid>,failed,(<id>,inbox,<serverid>,<req#>),errcode:<errcode>,reason:<reason>)

  The server will not allow a spend to be done if there are any inbox
  entries with a server-signed timestamp less than /account/<id>/last,
  except the first spend after a processinbox that clears the
  inbox. This forces customers to complete inbox transactions, and be
  in sync with the server about their balances and outbox contents, if
  they want to be able to do spends. Allowing the first spend after
  the inbox is cleared to got through ensures that frequent spends
  into your account don't lock you out from doing spends yourself.

Process Inbox
-------------

  Customer sends:

(<id>,processinbox,<serverid>,<time12#>,<time6#>|<time7#>|<time8#>|<time9#>).
  (<id>,spend|accept,<serverid>,<id4>,<time4#>,note:<note42>).
  (<id>,spend|reject,<serverid,<id5>,<time5#>,note:<note52>).
  (<id>,balance,<serverid>,<time12#>,<assetid>,<amount>,acct:<acct>).
  (<id>,storagefee,<serverid>,<time12#>,<assetid>,<storageamount>).
  (<id>,fraction,<serverid>,<time12#>,<assetid>,<fractionamount>).
  (<id>,balance,<serverid>,<time12#>,assetid2>,<amount2>,acct:<acct2>).
  (<id>,storagefee,<serverid>,<time12#>,<assetid2>,<storageamount2>).
  (<id>,fraction,<serverid>,<time12#>,<assetid2>,<fractionamount2>).
  ...
  (<id>,balance,<serverid>,<time12#>,<assetidN>,<amount3>,acct:<acctN>).
  (<id>,storagefee,<serverid>,<time12#>,<assetidN>,<storageamountN>).
  (<id>,fraction,<serverid>,<time12#>,<assetidN>,<fractionamountN>).
  (<id>,outboxhash,<serverid>,<time12#>,<outboxcount>,<outboxhash>).
  (<id>,balancehash,<serverid>,<time12#>,<balancecount>,<balancehash>)

  Server compares <time12#> to /account/<id>/time. If it's the
  same, server processes the requested inbox transactions, and compares
  the result to the balances and hashes sent by customer. If
  correct, server computes the response below, stores it in
  /account/<id>/tranaction, and responds with:

(<serverid,@processinbox,(<id>,processinbox,<serverid>,<time12#>,<time7#>|<time8#>|<time9#>).
  (<serverid>,@spend|accept,(<id>,spend|accept,<serverid>,<id4>,<time4#>,note:<note42>)).
  (<serverid,@spend|reject,(<id>,spend|reject,<serverid,<id5>,<time5#>,note:<note52>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time12#>,<assetid>,<amount>,acct:<acct>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,time12#>,assetid2>,<amount2>,acct:<acct2>)).
  ...
  (<serverid>,@balance,(<id>,balance,<serverid>,<time12#>,<assetidN>,<amount3>,acct:<acctN>)).
  (<serverid>,@outboxhash,(<id>,outboxhash,<serverid>,<time12#>,<outboxcount>,<outboxhash>)).
  (<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time12#>,<balancecount>,<balancehash>))

  Otherwise, server returns:

(<serverid>,failed,(<id>,processinbox,<serverid>,<time12#>|<time6#>|<time7#>|<time8#>|<time9#>),errcode:<errcode>,reason:<reason>)

  Again, that was the first phase of the two phase commit.

  To commit the transaction, the customer countersigns the
  balancehash, and sends it back to the server:

(<id>,commit,(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time12#>,<balancecount>,<balancehash>)))

  The server sets /account/<id>/time to <time12#>, removes the
  transaction from /account/<id>/inbox/, removes completed
  transactions from /account/<id>/outbox/, signs and adds spend|accept
  and spend|reject items to the other customers' inboxes, updates the
  /account/<id>/balance/<acctN>/<assetidN> with the balances from
  /account/<id>/transaction, updates /account/<id>/outboxhash, and
  /account/<id>/balancehash with the signed hashes, and sends back:

(<serverid>,@commit,(<id>,commit,(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time12#>,<balancecount>,<balancehash>))))

  If the server no longer has a record of the first phase of the
  transaction, it will send:

(<serverid>,failed,(<id>,commit,(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))),errcode:<errcode>,reason:<reason>)

  If the customer disagrees with the servers first response, he can
  rollback the transaction by sending:

(<id>,rollback,<serverid>,<time12#>)

  The server removes the /account/<id>/transaction file, and responds
  with:

(<serverid>,@rollback,(<id>,rollback,<serverid>,<time12#>))

  This is the most complicated function in the system. It has to deal
  with two kinds of inbox items. The first is spontaneous spends from
  another customer. These get deposited in your account if you
  accept. Whether accepted or rejected gets put in the other guys
  inbox, where it becomes the second type of inbox item. These
  acknowledge earlier spends. When you process one of them, it and the
  corresponding outbox item can be removed, forever.

  Note that the customer decides which <acct> names will get the spends
  and the usage token refunds by where he specifies the balances in the
  "balance" items. The server only verifies that the assets can be
  distributed as the customer requested.

  Rejected spends credit the usage tokens to the recipient, not the
  spender. This discourages spam, even in an otherwise free server.


Accept storage fees
-------------------

  Customer sends:

(<id>,storagefees,<serverid>,<req#>)

  Server compares <req#> to /account/<id>/req. If <req#> is greater,
  server sets /account/<id>/req to <req#>. Then server subtracts the
  integer parts from the storage fees in /account/<id>/storagefee,
  turns them into server spends on the inbox, and returns:

(<serverid>,@storagefees,(<id>,storagefees,<serverid>,<req#>))

  Otherwise, server returns:

(<serverid>,failed,(<id>,storagefees,<serverid>,<req#>),errcode:<errcode>,reason:<reason>)

Lookup asset
------------

  Customer sends:

(<id>,getasset,<req#>,<serverid>,<assetid>)

  Server compares <req#> to /account/<id>/req. If <req#>
  is greater, server sets /account/<id>/req to <req#>. Then,
  if <assetid> exists in /asset, server returns:

(<serverid>,@asset,(<issuerid>,asset,<serverid>,<assetid>,<scale>,<precision>,<assetname>)).
(<serverid>,@storage,(<issuerid>,storage,<serverid>,<time#>,<assetid>,<percent>))

  Where the @storage item is optional.
  Otherwise, server returns:

(<serverid>,failed,(<id>,getasset,<serverid>,<assetid>,<random>),errcode:<errcode>,reason:<reason>)


Create asset
------------

  Customer sends:

(<id>,asset,<serverid>,<assetid>,<scale>,<precision>,<assetname>).
  (<id>,storage,<serverid>,<assetid>,<time4#>,<percent>).
  (<id>,fee,<serverid>,<time4#>,asset,<feeassetid>,<feeamount>).
  (<id>,balance,<serverid>,<time4#>,<assetid>,-1,acct:<acct1>).
  (<id>,balance,<serverid>,<time4#>,assetid2>,<amount2>acct:<acct2>).
  ...
  (<id>,balance,<serverid>,<time4#>,<assetidN>,<amountN>,acct:<acctN>).
  (<id>,balancehash,<serverid>,<time4#>,<balancecount>,<balancehash>)

  Note that the balance for the new asset is "-1". Like loom, the sum
  of all balances for an <assetid> add up to -1. A negative balance
  means that the owner is the issuer. I haven't worked out the process
  to switch issuer ownership.

  If <assetid> is the hash of <id>,<scale>,<precision>,<assetname>,
  /asset/<assetid> does not exist, <time4#> is equal to
  /account/<id>/time, the customer has properly subtracted fees from
  the balances in /account/<id>/balance/<acctN> (including 1 usage
  token for the /asset/<assetid> file, 1 usage token for the balance
  file for the new asset, and the non-refundable asset creation fee),
  and the balancehash matches, then server adds
  <assetid>=(<id>,asset,<assetid>,<scale>,<precision>,<assetname>) to
  /asset/, clears /account/<id>/time, and returns:

(<serverid>,@asset,(<id>,asset,<serverid>,<assetid>,<assetname>)).
  (<serverid>,@storage,(<id>,storage,<serverid>,<time4#>,<assetid>,<percent>)).
  (<serverid>,@fee,(<id>,fee,<serverid>,asset,<feeassetid>,<feeamount>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time4#>,<assetid>,-1,acct:<acct1>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time4#>,assetid2>,<amount2>acct:<acct2>)).
  ...
  (<serverid>,@balance,(<id>,balance,<serverid>,<time4#>,assetidN>,<amountN>acct:<acctN>)).
  (<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time4#>,<balancecount>,<balancehash>))

  Otherwise, server returns:

(<serverid>,failed,(<id>,asset,<serverid>,<assetid>,<assetname>),errcode:<errcode>,reason:<reason>)

  The "storage" fee is optional. To change or add a storage fee, send a new
  "asset" message with the new storage fee. This costs 1 usage token, even
  though it doesn't use up any more files in storage. This prevents
  too-frequent changes, and forces using a new timestamp.

Get outbox
----------

  If customer needs to get back in sync with his outbox, he can send:

(<id>,getoutbox,<serverid>,req#>)

  Server compares <req#> to /account/<id>/req. If <req#>
  is greater, server sets /account/<id>/req to <req#>. Then,
  if the <id> exists, server returns:

(<serverid>,@getoutbox,(<id>,getoutbox,<serverid>,<req#>).
  (<serverid>,@spend,(<id>,spend,<time2#>,<id2>,<serverid>,<assetid2>,<amount2>,note:<note2>,acct:<acct2>))
  (<serverid>,@spend,<id>,spend,<time3#>,<id3>,<serverid>,<assetid3>,<amount3>,note:<note3>,acct:<acct3>))
  ...
  (<serverid>,@outboxhash,(<id>,outboxhash,<time#>,<serverid>,<hash>))

  Otherwise, server returns:

(<serverid>,failed,(<id>,getoutbox,<serverid>,req#>),errcode:<errcode>,reason:<reason>)


Get balance
-----------

  If the customer loses track of a balance, customer can send:

(<id>,getbalance,<serverid>,<req#>,acct:<acct>,asset:<assetid>)

  Server compares <req#> to /account/<id>/req. If <req#> is greater,
  server sets /account/<id>/req to <req#>.  Then server returns
  information about the specified <acct>s and <assetid>s If acct is
  not specified then information about all accounts is returned. If
  assetid is not specified, then information about all assetids is
  returned. The "fraction" balances are returned only if <acct> is not
  specified.

(<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid>,<amount>,acct:<acct>)).
(<serverid>,@balance,(<id>,balance,<serverid>,<time2#>,<assetid2>,<amount2>,acct:<acct2>)).
...
(<serverid>,@balance,(<id>,balance,<serverid>,<timeN#>,<assetidN>,<amountN>,acct:<acctN>)).
(<serverid>,@fraction,(<id>,fraction,<serverid>,<timef1#>,<assetid>,<amountf1>).
(<serverid>,@fraction,(<id>,fraction,<serverid>,<timef2#>,<assetid>,<amountf2>).
...
(<serverid>,@fraction,(<id>,fraction,<serverid>,<timefN#>,<assetid>,<amountfN>).
(<serverid>,storagefee,<serverid>,<time#>,<assetid>,<amount>).
(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))

  Otherwise, server returns:

(<serverid>,failed,(<id>,getbalance,<serverid>,<req#>,acct:<acct>,assetid:<assetid>),errcode:<errcode>,reason:<reason>)


Coupons
-------
  Customer sends:

(<id>,spend,<serverid>,<time#>,coupon,<assetid>,<amount>,note:<note>))
  (<id>,tranfee,<serverid>,<time#>,<tokenid>,<amount2fee>).
  (<id>,balance,<serverid>,<time#>,<assetid>,<amount>,acct:<acct>).
  (<id>,balance,<serverid>,<time#>,<assetid2>,<amount2>,acct:<acct2>).
  ...
  (<id>,balance,<serverid>,<time#>,<assetidN>,<amountN>,acct:<acctN>).
  (<id>,outboxhash,<serverid>,<time#>,<outboxcount>,<outboxhash>).
  (<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>)

  Server checks that the <time#> is equal to /account/<id>/time, that
  the balances match (after subtracting the spend amount fees), and
  that the hashes match what the customer sent. If they match, server
  computes the item list below, stores it in the database in the file
  /account/<id>/outbox, and returns:

(<serverid>,@spend,(<id>,spend,<time#>,spend,<serverid>,<assetid>,<amount>,note:<note>,acct:<acct>)).
  (<serverid>,couponenvelope,<id>,<encrypted-coupon>).
  (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time#>,<tokenid>,<amount2fee>)).
  (<serverid>,@balance,(<id>,balance,<time#>,<serverid>,<assetid>,<amount>,acct:<acct>)).
  (<serverid>,@balance,(<id>,balance,<time#>,<serverid>,assetid2>,<amount2>,acct:<acct2>)).
  ...
  (<serverid>,@balance,(<id>,balance,<time#>,<serverid>,<assetidN>,<amountN>,acct:<acctN>)).
  (<serverid,@outboxhash,(<id>,outboxhash,<serverid>,<time#>,<outboxcount>,<outboxhash>)).
  (<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))

  Where <encrypted-coupon> is the following, encrypted with the public
  key for <id>:

(<serverid>,coupon,<serverurl>,<coupon>,<assetid>,<amount>,note:<note>)

  <coupon> is the coupon number, a random ID.

  Server also stores, at coupon/<couponhash> (the hash of the <coupon>
  number)  the following:

(<serverid>,@spend,(<id>,spend,<serverid>,<time#>,coupon,<assetid>,<amount>,note:<note>))

  Note that this makes it impossible for the server alone to reproduce
  the coupon, since there's no plain-text copy of the coupon number.
  The only copy of the coupon number is in the customer's outbox,
  encrypted to his public key. This protects coupons from being
  revealed, even if the database is revealed.

  If the balances, balancehash, or outboxhash don't match, server returns:

(<serverid>,failed,(<id>,spend,<serverid>,<time#>,coupon,<assetid>,<amount>,note:<note>),errcode:<errcode>,reason:<reason>)

  This is an alternative form of the "spend" command. It creates a
  bearer coupon. Intead of putting an entry in the inbox of the
  recipient, it stores it in the "coupon" area of the database. It
  returns the coupon to the spender, encrypted with his public key.
  He can then give it to whomever he pleases, and that person can
  redeem it, with the couponenvelope request below. This is the normal
  way to introduce someone to a Truledger server.


Redeeming Coupons
-----------------
  Customer sends:

(<id>,couponenvelope,<serverid>,<encrytped-coupon>)

  Where <encrypted-coupon> is the following, encrypted to the server's
  public key.

(<serverid>,coupon,<serverurl>,<coupon>,<assetid>,<amount>,note:<note>)

  Server checks at coupon/<coupon> to make sure the coupon hasn't yet
  been spent, enters in the inbox of <id>, an entry that looks like a
  spend from the server for <assetid><amount>, enters in the inbox of
  the original creator of the coupon an entry that looks like a
  spendaccept from the server for the spend that created the coupon, and
  returns:

(<serverid>,@couponenvelope,(<id>,couponenvelope,<serverid>,<encrytped-coupon>))

  Where <encrypted-coupon> is the coupon above, encrypted to the
  server's public key.

  Note that the inbox item on the server has an additional
  "couponnumberhash" message, which encodes the hash of the coupon
  number, so that the server can recreate the coupon if the redeemer
  rejects the spend. The "getinbox" command does not return the
  couponhash to the client. It looks to the client like a regular
  spend, except the <id> field in the spend is "coupon".

  If the coupon has already been spent, server returns:

(<serverid>,failed,(<id>,couponenvelope,<serverid>,<encrytped-coupon>),errcode:<errcode>,reason:<reason>)


Switching Asset Issuance
------------------------

Asset issuance is switched by doing a negative spend of the whole
negative amount from the <acct> holding the negative amount. This can
move issuance to another <acct> or to another customer.


Write data
----------

  Customer sends:

(<id>,writedata,<serverid>,<time#>,<anonymous>,<key>,<data>).
(<id>,balance,<serverid>,<time#>,<tokenid>,<feeamount>).
(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>)

  Server returns:

(<serverid>,@writedata,<id>,<time#>,<anonymous>,<key>).
(<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<tokenid>,<feeamount>)).
(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))

  <id>.<time#>.<data> is written to the database at dir/<keyhash>,
  where <keyhash> is sha1(<key>), if <anonymous> is non-blank, or
  sha1(<id>.<key>) otherwise. If there's already data stored for a
  different <id> at data/<keyhash>, which is unlikely, unless you
  choose a common value for <key>, and are writing <anonymous>ly,
  you'll get an error. It costs 1 token per 4096-bytes of saved data
  (counting the entire <id>.<time#>.<data> string). A non-blank value
  of <anonymous> will allow the data to be fetched with an unsigned
  readdata request. Otherwise, only the <id> who wrote the data can
  read it.


Read Data
---------

  Customer sends:

(<id>,readdata,<serverid>,<req#>,<key>,size=<size>)

  Or, for <anonymous> writes:

(0,readdata,<serverid>,0,<key>,size=<size>):0

  Server returns:

(<serverid>,@readdata,<id>,<time#>,<key>,<data>)

  Unsigned messages are allowed to fetch <anonymous> data, so that
  this can be used to cache private keys on the server, stored with
  the hash of the user's passphrase. If <size> is non-blank, The
  <data> returned will be the size of the data, as an integer, not the
  data itself.


Grant permission
----------------

  Customer sends:

(<id>,grant,<serverid>,<time#>,<toid>,<permission>,grant=grant)

  Server compares <time#> to /account/<id>/time. If it's the
  same, server checks that <id> has permission to grant <permission>, if so,
  server returns and stores at account/<id>/permissions/<permission>:

(<serverid>,@grant,(<id>,grant,<serverid>,<req#>,<toid>,<permission>,grant=grant))

  Even though it requires a file to store, granting permissions is free.

  if "grant" is included after <permission> in the message, then this
  is a "transitive grant". <id> is allowed to grant the permission to
  others. Otherwise, <id> can only use the permission.

  The server has grant permission for all permissions. If the server grants
  itself a permission, then other accounts need that permission to do
  what it controls. If the server does NOT have a permission, then everybody
  is allowed to do what it controls, without permission.

  Useful permissions:

  mint-tokens
    allows minting of usage token coupons and spending of usage tokens
    to new accounts. If the server requires this permission, then only
    it or its proxies can give new acccounts. Allows the server to
    enforce know-your-customer type rules.

  mint-coupons
    Sometimes you want to also control the minting of non-token coupons.

  add-asset
    allows the creation of new assets. If the server requires this permission,
    then only it or its proxies can create new asset types.


Remove permission
-----------------

  Customer sends:

(<id>,deny,<serverid>,<req#>,<toid>,<permission>)

  Server removes the grant record from <id> stored at
  account/<toid>/permissions/<permission>. The server can remove any
  grant record. Other users can only remove grant records that they
  directly created. If the removed grant record has transitive grant
  permission, then all transitively granted permissions are also
  removed.

  Acknowledged with:

(<serverid>,@deny,(<id>,deny,<serverid>,<req#>,<toid>,<permission>))

  If more than one <id> grants a permission to <toid>, then all
  of them will be stored at account/<toid>/permissions/<permission>,
  separated by periods. Transively granted permissions will only be
  removed when the last permission containing the final "grant" is
  removed.


Get permissions
---------------

Customer sends:

(<id>,permission,<serverid>,<req#>,grant=grant)

  If the final grant arg is included, and is "grant", searches all
  accounts for permission directly granted by <id>. If "grant" is
  NOT included, returns a list of all permissions granted to <id>.
  If a permission is required, but NOT granted to <id>, returns the
  server's grant record for that permission.

  Server returns:

(<serverid>,@permission,(<id>,permission,<serverid>,<req#>,grant=grant).
(<serverid>,@grant,(<id>,grant,<serverid>,<time#>,<toid>,<permission>,grant=grant)).
(<serverid>,@grant,(<id2>,grant,<serverid>,<time#2>,<toid2>,<permission>,grant=grant)).
...
(<serverid>,@grant,(<idN>,grant,<serverid>,<time#N>,<toidN>,<permission>,grant=grant)).

  When the final grant arg is NOT "grant", there will be three kinds
  of grant messages returned. Expliticitly granted permissions will
  have a <toid> of <id> and a non-blank <time>. Default permissions,
  not controlled by the server, will have a <toid> of <id> and a blank
  <time>. Non-granted, but required permissions will have a <toid> of
  <serverid>.


Audit
-----

  Customer sends:

(<id>,audit,<serverid>,<req#>,<asset>)

  Where <asset> is any <asset> that <id> issues, or any asset if <id>
  is <serverid>. The server walks the entire database, adding up
  balances for the specified <asset>. It returns a server-signed
  balance message, and, optionally, a server-signed fraction message,
  giving how much needs to be added to the <asset> to bring it into
  balance. If a balance amount is positive, then there are more claims
  on the asset than the issuer thinks he has given out. If negative,
  then there are fewer claims on the asset than the issuer thinks he's
  given out. Server returns:

(<serverid>,@audit,(<id>,audit,<serverid>,<req#>,<asset>)).
(<serverid>,balance,<serverid>,<req#>,<asset>,<amount>,audit).
(<serverid>,fraction,<serverid>,<req#>,<asset>,<fraction>)

  Note that the <req#> is returned in the <time#> location of the
  "balance" and "fraction" items.

  I have not yet implemented auditing of the usage tokens. Both client
  and server get an error if you attempt that.

  Balances in the asset issuer's "audit" acct are not included, so he
  can spend to that acct to balance his books of auditing debits,
  keeping track of how much he's had to do so over time. I haven't
  thought of a good way to balance out auditing credits. Maybe I
  should allow the "audit" acct balance to go negative, but that's a
  bunch of special casing for no good reason.


Disagreement Resolution
-----------------------

  Customer sends:

(<id>,resolve,<serverid>,<time#>).
(<serverid>,@balance,(<id>,balance,<serverid>,<time1#>,<assetid1>,<amount1>,acct:<acct1>))
(<serverid>,@fraction,(<id>,fraction,<serverid>,<time1#>,<assetid1>,<fractionamount1>).
...
(<serverid>,@balance,(<id>,balance,<serverid>,<timeN#>,<assetidN>,<amountN>,acct:<acctN>)).
(<serverid>,@fraction,(<id>,fraction,<serverid>,<timeN#>,<assetidN>,<fractionamountN>).
(<id>,balancehash,<serverid>,<time#>,<count>,<hash>).
(<serverid>,@spend,(<id>,spend,<serverid>,<timeA#>,<idA>,<assetidA>,<amountA>,note:<noteA>)).
(<serverid>,@tranfee,(<id>,tranfee,<serverid>,<timeA#>,<tokenid>,<amountAfee>))
...
(<serverid>,@spend,(<id>,spend,<serverid>,<timeZ#>,<idZ>,<assetidZ>,<amountZ>,note:<noteZ>)).
(<serverid>,@tranfee,(<id>,tranfee,<serverid>,<timeZ#>,<tokenid>,<amountZfee>)).
(<serverid>,@outboxhash,(<id>,outboxhash,<serverid>,<timeX#>,<count>,<hash>).
(<id>,outboxhash,<serverid>,<time#>,<count>,<hash>)

  The "@balance" messages are balances for which the client has a
  newer transaction time than the server. Some, but not all, of them
  will have associated "@fraction" messages, possibly with different
  transaction times. The "@spend"/"@tranfee" pairs are outbox
  entries. If they are included, ALL the outbox entries must be
  included, and the time on the "@outboxhash" message must be greater
  than or equal to the time of the server's existing "@outboxhash"
  message. Note that the "balancehash" message is new, having the same
  transaction time as the "resolve" message. This enables mixing
  server and client balances to arrive at the latest value for
  each. You can't do that with the outbox. Either the server or the
  client has the right outbox contents. Mixing can't be done. The
  server CAN check for corresponding inbox entries, but that gets
  complicated fast. Note that the outbox hash is sent twice, once
  countersigned by the server, and once NOT countersigned and with the
  new "resolve" transaction time. This enables a newly countersigned
  balancehash.

  The server checks that everything looks hunky-dory, updates its
  database, and sends back:

(<serverid>,@resolve,(<id>,resolve,<serverid>,<time#>)).
(<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<count>,<hash>)).
(<serverid>,@outboxhash,(<id>,outboxhash,<serverid>,<time#>,<count>,<hash>))

  Or, if things don't look right:

(<serverid>,failed,(<id>,resolve,<serverid>,<time#>),errcode:<errcode>,reason:<reason>)

  This resolution can cause assets to go out of balance. There
  probably needs to be some sort of inbox entry for the asset issuer
  allowing him to invoice the server operator for the loss. Probably,
  asset issuers will want a limit to those losses, which will push the
  loss back on the customer. This needs more thought.


Session encryption
------------------

  Truledger does its own transmission encryption. The customer can
  request an encryption "session". Any commands sent encrypted will be
  returned encrypted. Session keys are generated by the server and
  returned to the customer, encrypted to the customer's public
  key. Session messages are encrypted with AES-128, using CBC.

  Customer sends:

(<id>,opensession,<serverid>,<req#>,timeout=<timeout>,inactivetime=<inactivetime>)

  Server checks that <req#> is valid, generates a new sessionid and
  random 128-bit session key, enters the id and key in an in-memory
  table, and returns:

(<serverid>,@opensession,(<id>,opensession,<serverid>,<req#>,,timeout=<timeout>,inactivetime=<inactivetime>),<pubkey encrypted: [<sessionid>,<sessionkey>]>)

(<serverid>,failed,(<id>,opensession,<serverid>,<req#>),errcode:<errcode>,reason:<reason>)

  The <sessionid> is a string to be used unchanged. The <sessionkey>
  is a base64-encoded 16-byte (128-bit) array. Creating a new session
  does NOT remove old sessions, to allow sessions to remain open on
  multiple client devices for the same user. But a customer is allowed
  a maximum of 5 active sessions. Attempt to create a sixth session
  will close the one least-recently active. <timeout> is the total time
  the session is allowed to remain active, in seconds, it defaults to
  300, 5 minutes. <inactivetime> is the time the session is allowed to
  remain inactive. It defaults to 3600, 60 minutes.

  To send an encrypted message, either direction:

[<sessionid>,<iv>,<sessionkey encrypted: message>]

  Where <iv> is a base64 representation of a 16-byte random
  initialization vector for the AES CBC encryption.

  If the server receives an encrypted message and the <sessionid>
  isn't registered, or has expired, or some other errors occurs in
  message decryption or response encryption, it returns:

[<sessionid>,error,<error message>]

  To explicitly close a session, the customer sends (usually encrypted
  to the session key):

(<id>,closesession,<serverid>,<req#>,<sessionid>)

  The server returns (again, usually encrypted to the session key):

(<serverid>,@closesession,(<id>,closesession,<serverid>,<req#>,<sessionid>))


Backup
------
  Customer sends:

(<id>,backup,<req#>,<key1>,<value1>,<key2>,<value2>,...)

  Server checks that <id> is the serverid, then stores <valuei> at <keyi> in
  the database. Server returns:

(<serverid>,@backup,<req#>)


Setting the Automatic Vend Acct
-------------------------------
  Customer sends:

(<id>,vendacct,<serverid>,<time#>,<acct>)

  Server checks that <time#> is equal to /account/<id>/time, then signs
  the message, stores it in /account/<id>/vendacct, and returns:

(<serverid>,@vendacct,(<id>,vendacct,<serverid>,<time#>,<acct>))

  This specified the acct that will be used as a source for automatic
  vends. The default is the "main" acct.


Creating an Automatic Vend
--------------------------
  Customer sends:

(<id>,defvend,<serverid>,<time#>,<vend#>,expires=<expirationtime#>,note=<description>).
  (<id>,vendin,<serverid>,<time#>,<vend#>,<assetid1>,<amount1>).
  (<id>,vendin,<serverid>,<time#>,<vend#>,<assetid2>,<amount2>).
  ...
  (<id>,vendin,<serverid>,<time#>,<vend#>,<assetidN>,<amountN>).
  (<id>,vendout,<serverid>,<time#>,<vend#>,<assetid-o1>,<amount-o1>).
  (<id>,vendout,<serverid>,<time#>,<vend#>,<assetid-o2>,<amount-o2>).
  ...
  (<id>,vendout,<serverid>,<time#>,<vend#>,assetid-oM>,<amount-oM>)

  Server checks that <time#> is equal to /account/<id>/time, checks that
  there is no overlap between the <assetidI> and the <assetid-oI>,
  then signs the entire message (not each component), stores that in
  the database at /defvend/<vend#>, overwriting an earlier definition
  for the same <vend#>, if there, and returns:

(<serverid>,@defvend,
  (<id>,defvend,<serverid>,<time#>,<vend#>,expires=<expirationtime#>,note=<description>).
  (<id>,vendin,<serverid>,<time#>,<vend#>,<assetid1>,<amount1>).
  (<id>,vendin,<serverid>,<time#>,<vend#>,<assetid2>,<amount2>).
  ...
  (<id>,vendin,<serverid>,<time#>,<vend#>,<assetidN>,<amountN>).
  (<id>,vendout,<serverid>,<time#>,<vend#>,<assetid-o1>,<amount-o1>).
  (<id>,vendout,<serverid>,<time#>,<vend#>,<assetid-o2>,<amount-o2>).
  ...
  (<id>,vendout,<serverid>,<time#>,<vend#>,assetid-oN>,<amount-oN>))

  This defines a vending machine, an automated trade. Anyone who knows
  <id> and <vend#> can invoke this trade with the "vend" message
  below, by spending a multiple of the "vendin" assets, to receive the
  same multiple of the "vendout" assets. Spent assets come from the
  "vendacct", set above. Received assets go into the "vendpool", from
  which they can be transferred to the inbox with the "vendpool"
  message below.


Trade with an Automated Vend
----------------------------
  Customer sends:

(<id>,vend,<serverid>,<time#>,<id2>,<vend#>,<count>).
  (<id>,spend,<serverid>,<time#>,<assetid1>,<amount1>).
  (<id>,spend,<serverid>,<time#>,assetid2>,<amount2>).
  ...
  (<id>,spend,<serverid>,<time#>,<assetidN>,<amountN>).
  (<id>,tranfee,<serverid>,<time#>,<tokenid>,<amount2fee>).
  (<id>,storagefee,<serverid>,<time#>,<assetid>,<storageamount>).
  (<id>,balance,<serverid>,<time#>,<assetid>,<amount>,acct:<acct>).
  (<id>,fraction,<serverid>,<time#>,<assetid>,<fractionamount>).
  (<id>,balance,<serverid>,<time#>,<assetid2>,<amount2>,acct:<acct2>).
  (<id>,fraction,<serverid>,<time#>,<assetid2>,<fractionamount2>).
  ...
  (<id>,balance,<serverid>,<time#>,<assetidN>,<amountN>,acct:<acctN>).
  (<id>,fraction,<serverid>,<time#>,<assetidN>,<fractionamountN>).
  (<id>,balance,<serverid>,<time#>,<assetid-o1>,<amount>,acct:<acct>).
  (<id>,fraction,<serverid>,<time#>,<assetid-o1>,<fractionamount>).
  (<id>,balance,<serverid>,<time#>,<assetid-o2>,<amount2>,acct:<acct2>).
  (<id>,fraction,<serverid>,<time#>,<assetid-o2>,<fractionamount2>).
  ...
  (<id>,balance,<serverid>,<time#>,<assetid-oN>,<amount-oN>,acct:<acctN>).
  (<id>,fraction,<serverid>,<time#>,<assetid-oN>,<fractionamount-oN>).
  (<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>)

  Server checks that <time#> is equal to /account/<id>/time, checks that
  the spends on the <assetidI> are <count> times the "vendin" values
  in the definition at /account/<id2>/defvend/<vend#>, and that the
  existing user balances minus the "spend"s match the corresponding
  "balance" and "fraction" messages, and that the user balances plus
  the vending machine "vendout" items times <count> match the
  corresponding "balance" and "fraction" messages. It also verifies
  that the passed-in "balancehash" is what it ought to be, given the
  updates balances. "tranfee" usage tokens are charged only for new
  balance items; the transaction itself is free to the trader. Next,
  it updates the /vendpool/<id2>/<assetI> and
  /vendpool/<id2>/asset-oI> messages with the "spend" amounts received
  and the "vendout" amounts spent. Finally, it updates the user
  balances, fractions, and balancehash, with server-signed messages, and
  returns:

(<serverid>,@vend,(<id>,vend,<serverid>,<time#>,<id2>,<vend#>,<count>).
  (<serverid>,@spend,(<id>,spend,<serverid>,<time#>,<id2>,<assetid1>,<amount1>)).
  (<serverid>,@spend,(<id>,spend,<serverid>,<time#>,<id2>,assetid2>,<amount2>)).
  ...
  (<serverid>,@spend,(<id>,spend,<serverid>,<time#>,<id2>,<assetidN>,<amountN>)).
  (<serverid>,@tranfee,(<id>,tranfee,<serverid>,<time#>,<tokenid>,<amount2fee>)).
  (<serverid>,@storagefee,(<id>,storagefee,<serverid>,<time#>,<assetid>,<storageamount>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid>,<amount>,acct:<acct>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid>,<fractionamount>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid2>,<amount2>,acct:<acct2>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid2>,<fractionamount2>)).
  ...
  (<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetidN>,<amountN>,acct:<acctN>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetidN>,<fractionamountN>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid-o1>,<amount>,acct:<acct>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid-o1>,<fractionamount>)).
  (<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid-o2>,<amount2>,acct:<acct2>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid-o2>,<fractionamount2>)).
  ...
  (<serverid>,@balance,(<id>,balance,<serverid>,<time#>,<assetid-oN>,<amount-oN>,acct:<acctN>)).
  (<serverid>,@fraction,(<id>,fraction,<serverid>,<time#>,<assetid-oN>,<fractionamount-oN>)).
  (<serverid>,@balancehash,(<id>,balancehash,<serverid>,<time#>,<balancecount>,<balancehash>))

  
Accept Automatic Vends
----------------------

  Customer sends:

(<id>,vendpool,<serverid>,<req#>)

  Server compares <req#> to /account/<id>/req. If <req#> is greater,
  server sets /account/<id>/req to <req#>. Then server signs, as "inbox"
  items, and moves the spends on /account/<id>/vendpool to the
  customer's inbox, and returns:

(<serverid>,@vendpool,(<id>,vendpool,<serverid>,<time#>))

  Otherwise, server returns:

(<serverid>,failed,(<id>,vendpool,<serverid>,<time#>),errcode:<errcode>,reason:<reason>)


// Copyright 2008-2010 Bill St. Clair
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.
